/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => NoteToolbarPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian9 = require("obsidian");

// src/Settings/NoteToolbarSettingTab.ts
var import_obsidian8 = require("obsidian");

// src/Utils/Utils.ts
var DEBUG = false;
function arraymove(arr, fromIndex, toIndex) {
  if (toIndex < 0 || toIndex === arr.length) {
    return;
  }
  const element = arr[fromIndex];
  arr[fromIndex] = arr[toIndex];
  arr[toIndex] = element;
}
function migrateItemVisPlatform(hideOnDesktop, hideOnMobile) {
  if (!hideOnDesktop && !hideOnMobile) {
    return "all";
  } else if (hideOnDesktop && hideOnMobile) {
    return "none";
  } else if (hideOnMobile) {
    return "desktop";
  } else if (hideOnDesktop) {
    return "mobile";
  } else {
    return "all";
  }
}
function calcComponentVisToggles(visibility) {
  const desktopComponents = hasComponents(visibility.desktop);
  const mobileComponents = hasComponents(visibility.mobile);
  const tabletComponents = hasComponents(visibility.tablet);
  return desktopComponents.concat(mobileComponents, tabletComponents);
}
function hasComponents(platform) {
  let hasIcon = false;
  let hasLabel = false;
  if (platform && platform.allViews) {
    hasIcon = platform.allViews.components.includes("icon");
    hasLabel = platform.allViews.components.includes("label");
  }
  return [hasIcon, hasLabel];
}
function calcItemVisToggles(visibility) {
  const desktopHasComponents = hasVisibleComponents(visibility.desktop);
  const mobileHasComponents = hasVisibleComponents(visibility.mobile);
  const tabletHasComponents = hasVisibleComponents(visibility.tablet);
  return [desktopHasComponents, mobileHasComponents, tabletHasComponents];
}
function hasVisibleComponents(platform) {
  return !!platform && !!platform.allViews && platform.allViews.components.length > 0;
}
function removeComponentVisibility(platform, component) {
  if (platform && platform.allViews) {
    const index = platform.allViews.components.indexOf(component);
    if (index !== -1) {
      platform.allViews.components.splice(index, 1);
    }
  }
}
function addComponentVisibility(platform, component) {
  if (platform && platform.allViews) {
    if (!platform.allViews.components.includes(component)) {
      platform.allViews.components.push(component);
    }
  }
}
function debugLog(message, ...optionalParams) {
  DEBUG && console.log(message, ...optionalParams);
}
function emptyMessageFr(message) {
  let messageFr = document.createDocumentFragment();
  let messageFrText = document.createElement("i");
  messageFrText.textContent = message;
  messageFr.append(messageFrText);
  return messageFr;
}
function learnMoreFr(message, url) {
  let messageFr = document.createDocumentFragment();
  messageFr.append(
    message,
    " ",
    messageFr.createEl("a", { href: url, text: "Learn\xA0more" })
  );
  return messageFr;
}
function getPosition(element) {
  const rect = element.getBoundingClientRect();
  return {
    x: rect.left + activeWindow.scrollX,
    y: rect.top + activeWindow.scrollY
  };
}
function hasVars(s) {
  const urlVariableRegex = /{{.*?}}/g;
  return urlVariableRegex.test(s);
}
var validUrlEl;
function isValidUri(u) {
  if (u !== "") {
    if (!validUrlEl) {
      validUrlEl = document.createElement("input");
      validUrlEl.setAttribute("type", "url");
    }
    validUrlEl.value = u;
    return validUrlEl.validity.valid;
  } else {
    return false;
  }
}

// src/Settings/ToolbarSettingsModal.ts
var import_obsidian5 = require("obsidian");

// src/Settings/NoteToolbarSettings.ts
var SETTINGS_VERSION = 202404261e-1;
var DEFAULT_SETTINGS = {
  folderMappings: [],
  icon: "circle-ellipsis",
  showEditInFabMenu: false,
  toolbarProp: "notetoolbar",
  toolbars: [],
  version: SETTINGS_VERSION
};
var DEFAULT_TOOLBAR_SETTINGS = {
  defaultStyles: ["border", "even", "sticky"],
  items: [],
  mobileStyles: [],
  name: "",
  position: {
    desktop: { allViews: { position: "props" } },
    tablet: { allViews: { position: "props" } },
    mobile: { allViews: { position: "props" } }
  },
  updated: new Date().toISOString()
};
var POSITION_OPTIONS = {
  desktop: [
    { top: "Top (fixed)" },
    { props: "Below Properties" },
    { hidden: "Hidden (do not display)" }
  ],
  mobile: [
    { top: "Top (fixed)" },
    { props: "Below Properties" },
    { fabl: "Floating button: left" },
    { fabr: "Floating button: right" },
    { hidden: "Hidden / Navigation bar" }
  ]
};
var DEFAULT_STYLE_OPTIONS = [
  { autohide: "auto-hide*" },
  { border: "border" },
  { button: "button" },
  { noborder: "no border" },
  { center: "center items" },
  { even: "evenly space items" },
  { left: "left align items" },
  { right: "right align items" },
  { sticky: "sticky*" },
  { nosticky: "not sticky" },
  { floatl: "float left*" },
  { floatr: "float right*" },
  { nofloat: "no float" }
];
var DEFAULT_STYLE_DISCLAIMERS = [
  { autohide: "Auto-hide does not apply on mobile." },
  { floatl: "Float left only works within callouts." },
  { floatr: "Float right only works within callouts." },
  { sticky: "Sticky does not apply in Reading mode." }
];
var MOBILE_STYLE_OPTIONS = [
  { mbrder: "border" },
  { mbtn: "button" },
  { mnbrder: "no border" },
  { mctr: "center items" },
  { mevn: "evenly space items" },
  { mlft: "left align items" },
  { mrght: "right align items" },
  { mstcky: "sticky*" },
  { mnstcky: "not sticky" },
  { mfltl: "float left*" },
  { mfltr: "float right*" },
  { mnflt: "no float" }
];
var MOBILE_STYLE_DISCLAIMERS = [
  { mfltl: "Float left only works within callouts." },
  { mfltr: "Float right only works within callouts." },
  { mstcky: "Sticky does not apply in Reading mode." }
];

// src/Settings/DeleteModal.ts
var import_obsidian = require("obsidian");
var DeleteModal = class extends import_obsidian.Modal {
  constructor(parent) {
    super(parent.plugin.app);
    this.modalEl.addClass("note-toolbar-setting-mini-dialog");
    this.parent = parent;
    this.plugin = parent.plugin;
    this.toolbar = parent.toolbar;
  }
  onOpen() {
    this.setTitle("Delete toolbar: " + this.toolbar.name);
    this.contentEl.createEl("p", { text: "Are you sure you want to delete this toolbar?" });
    const delete_button = this.contentEl.createEl("button", { text: "Yes, delete" });
    delete_button.onclick = async () => this.delete();
  }
  async delete() {
    this.plugin.deleteToolbarFromSettings(this.toolbar.name);
    await this.plugin.saveSettings();
    this.close();
    this.parent.close();
  }
};

// src/Settings/Suggesters/CommandSuggester.ts
var import_obsidian2 = require("obsidian");
var CommandSuggester = class extends import_obsidian2.AbstractInputSuggest {
  constructor(app, inputEl) {
    super(app, inputEl);
    this.inputEl = inputEl;
    this.commands = Object.values(this.app.commands.commands);
  }
  getSuggestions(inputStr) {
    const suggestions = [];
    const lowerCaseInputStr = inputStr.toLowerCase();
    this.commands.forEach((command) => {
      if (command.name.toLowerCase().contains(lowerCaseInputStr)) {
        suggestions.push(command);
      }
    });
    return suggestions;
  }
  renderSuggestion(command, el) {
    el.setText(command.name);
  }
  selectSuggestion(command) {
    this.inputEl.value = command.name;
    this.inputEl.setAttribute("data-command-id", command.id);
    this.inputEl.trigger("input");
    this.close();
  }
};

// src/Settings/IconSuggestModal.ts
var import_obsidian3 = require("obsidian");
var IconSuggestModal = class extends import_obsidian3.SuggestModal {
  constructor(plugin, settingsWithIcon, parentEl) {
    super(plugin.app);
    this.modalEl.addClass("note-toolbar-setting-mini-dialog");
    this.parentEl = parentEl;
    this.plugin = plugin;
    this.settingsWithIcon = settingsWithIcon;
    this.setPlaceholder("Search for an icon");
    this.setInstructions([
      { command: "\u2191\u2193", purpose: "to navigate" },
      { command: "\u21B5", purpose: "to use" },
      { command: "esc", purpose: "to dismiss" }
    ]);
  }
  getSuggestions(inputStr) {
    const iconIds = (0, import_obsidian3.getIconIds)();
    const iconSuggestions = [];
    const lowerCaseInputStr = inputStr.toLowerCase();
    iconSuggestions.push("No icon");
    iconIds.forEach((icon) => {
      if (icon.toLowerCase().contains(lowerCaseInputStr)) {
        iconSuggestions.push(icon);
      }
    });
    return iconSuggestions;
  }
  renderSuggestion(icon, el) {
    el.addClass("note-toolbar-icon-suggestion");
    let iconName = el.createSpan();
    if (icon === "No icon") {
      iconName.setText(icon);
    } else {
      iconName.setText(icon.startsWith("lucide-") ? icon.substring(7) : icon);
      let iconGlyph = el.createSpan();
      (0, import_obsidian3.setIcon)(iconGlyph, icon);
    }
  }
  /**
   * Saves the selected icon to settings, closes the modal, refreshes the parent.
   * @param selectedIcon Icon to save.
   */
  onChooseSuggestion(item, evt) {
    debugLog("onChooseSuggestion: ", this.settingsWithIcon);
    this.settingsWithIcon.icon = item === "No icon" ? "" : item;
    this.plugin.saveSettings();
    (0, import_obsidian3.setIcon)(this.parentEl, item === "No icon" ? "lucide-plus-square" : item);
    this.parentEl.setAttribute("data-note-toolbar-no-icon", item === "No icon" ? "true" : "false");
    this.close();
  }
};

// src/Settings/Suggesters/FileSuggester.ts
var import_obsidian4 = require("obsidian");
var FileSuggester = class extends import_obsidian4.AbstractInputSuggest {
  constructor(app, inputEl) {
    super(app, inputEl);
    this.inputEl = inputEl;
  }
  getSuggestions(inputStr) {
    const abstractFiles = this.app.vault.getAllLoadedFiles();
    let files = [];
    const lowerCaseInputStr = inputStr.toLowerCase();
    files = abstractFiles.filter(
      (file) => file instanceof import_obsidian4.TFile && file.path.toLowerCase().includes(lowerCaseInputStr)
    );
    return files;
  }
  renderSuggestion(file, el) {
    el.setText(file.path);
  }
  selectSuggestion(file) {
    this.inputEl.value = file.path;
    this.inputEl.trigger("input");
    this.close();
  }
};

// src/Settings/ToolbarSettingsModal.ts
var ToolbarSettingsModal = class extends import_obsidian5.Modal {
  /**
   * Displays a new edit toolbar modal, for the given toolbar.
   * @param app reference to the app
   * @param plugin reference to the plugin
   * @param parent NoteToolbarSettingTab if coming from settings UI; null if coming from editor 
   * @param toolbar ToolbarSettings to edit
   */
  constructor(app, plugin, parent = null, toolbar) {
    super(app);
    this.itemListOpen = true;
    this.parent = parent;
    this.plugin = plugin;
    this.toolbar = toolbar;
  }
  /**
   * Displays the toolbar item's settings within the modal window.
   */
  onOpen() {
    this.display();
  }
  /**
   * Removes modal window and refreshes the parent settings window.
   */
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    this.parent ? this.parent.display() : void 0;
  }
  /*************************************************************************
   * SETTINGS DISPLAY
   *************************************************************************/
  /**
   * Displays the toolbar item's settings.
   */
  display(focusOnLastItem = false) {
    this.modalEl.addClass("note-toolbar-setting-modal-container");
    this.contentEl.empty();
    let settingsDiv = this.containerEl.createDiv();
    settingsDiv.className = "vertical-tab-content note-toolbar-setting-modal";
    this.displayNameSetting(settingsDiv);
    this.displayItemList(settingsDiv);
    this.displayPositionSetting(settingsDiv);
    this.displayStyleSetting(settingsDiv);
    this.displayDeleteButton(settingsDiv);
    this.contentEl.appendChild(settingsDiv);
    if (focusOnLastItem) {
      let inputToFocus = this.contentEl.querySelector("#note-toolbar-setting-item-field-" + (this.toolbar.items.length - 1) + ' input[type="text"]');
      let inputContainer = inputToFocus.closest(".note-toolbar-setting-item");
      if ((inputToFocus == null ? void 0 : inputToFocus.value.length) === 0) {
        inputToFocus.focus();
        if (import_obsidian5.Platform.isMobile) {
          setTimeout(() => {
            inputContainer.scrollIntoView(true);
          }, 100);
        }
      }
    }
    this.rememberLastPosition(this.contentEl.children[0]);
  }
  /**
   * Displays the Name setting.
   * @param settingsDiv HTMLElement to add the setting to.
   */
  displayNameSetting(settingsDiv) {
    let toolbarNameDiv = this.containerEl.createDiv();
    new import_obsidian5.Setting(toolbarNameDiv).setName("Name").setDesc("Give this toolbar a unique name.").addText((text) => text.setPlaceholder("Name").setValue(this.toolbar.name).onChange((0, import_obsidian5.debounce)(async (value) => {
      var _a;
      let existingToolbar = this.plugin.getToolbarSettings(value);
      if (existingToolbar && existingToolbar !== this.toolbar) {
        toolbarNameDiv.createEl("div", {
          text: "A toolbar already exists with this name",
          attr: { id: "note-toolbar-name-error" },
          cls: "note-toolbar-setting-error-message"
        });
        toolbarNameDiv.addClass("note-toolbar-setting-error");
      } else {
        (_a = document.getElementById("note-toolbar-name-error")) == null ? void 0 : _a.remove();
        toolbarNameDiv.removeClass("note-toolbar-setting-error");
        this.toolbar.name = value;
        this.toolbar.updated = new Date().toISOString();
        this.plugin.settings.toolbars.sort((a, b) => a.name.localeCompare(b.name));
        await this.plugin.saveSettings();
      }
    }, 750)));
    settingsDiv.append(toolbarNameDiv);
  }
  /**
   * Displays the list of toolbar items for editing.
   * @param settingsDiv HTMLElement to add the settings to.
   */
  displayItemList(settingsDiv) {
    let itemsContainer = createDiv();
    itemsContainer.addClass("note-toolbar-setting-items-container");
    itemsContainer.setAttribute("data-active", this.itemListOpen.toString());
    let itemsSetting = new import_obsidian5.Setting(itemsContainer).setName("Items").setHeading().setDesc(learnMoreFr(
      "Items in the toolbar, in order from left to right.",
      "https://github.com/chrisgurney/obsidian-note-toolbar/wiki/Creating-toolbar-items"
    ));
    if (this.toolbar.items.length > 0) {
      itemsSetting.addExtraButton((cb) => {
        cb.setIcon("right-triangle").setTooltip("Collapse all items").onClick(async () => {
          let itemsContainer2 = settingsDiv.querySelector(".note-toolbar-setting-items-container");
          if (itemsContainer2) {
            this.itemListOpen = !this.itemListOpen;
            itemsContainer2.setAttribute("data-active", this.itemListOpen.toString());
            let heading = itemsContainer2.querySelector(".setting-item-heading .setting-item-name");
            this.itemListOpen ? heading == null ? void 0 : heading.setText("Items") : heading == null ? void 0 : heading.setText("Items (" + this.toolbar.items.length + ")");
            cb.setTooltip(this.itemListOpen ? "Collapse all items" : "Expand all items");
          }
        }).extraSettingsEl.tabIndex = 0;
        this.plugin.registerDomEvent(
          cb.extraSettingsEl,
          "keydown",
          (e) => {
            switch (e.key) {
              case "Enter":
              case " ":
                e.preventDefault();
                cb.extraSettingsEl.click();
            }
          }
        );
      });
    }
    let itemLinkFields = [];
    let itemsListContainer = createDiv();
    itemsListContainer.addClass("note-toolbar-setting-items-list-container");
    this.toolbar.items.forEach(
      (toolbarItem, index) => {
        let itemDiv = this.containerEl.createDiv();
        itemDiv.className = "note-toolbar-setting-item";
        let itemTopContainer = this.containerEl.createDiv();
        itemTopContainer.className = "note-toolbar-setting-item-top-container";
        let textFieldsContainer = this.containerEl.createDiv();
        textFieldsContainer.id = "note-toolbar-setting-item-field-" + index;
        textFieldsContainer.className = "note-toolbar-setting-item-fields";
        const s1a = new import_obsidian5.Setting(textFieldsContainer).setClass("note-toolbar-setting-item-icon").addExtraButton((cb) => {
          cb.setIcon(toolbarItem.icon ? toolbarItem.icon : "lucide-plus-square").setTooltip("Select icon (optional)").onClick(async () => {
            const modal = new IconSuggestModal(this.plugin, toolbarItem, cb.extraSettingsEl);
            modal.open();
          });
          cb.extraSettingsEl.setAttribute("data-note-toolbar-no-icon", !toolbarItem.icon ? "true" : "false");
          cb.extraSettingsEl.setAttribute("tabindex", "0");
          this.plugin.registerDomEvent(
            cb.extraSettingsEl,
            "keydown",
            (e) => {
              switch (e.key) {
                case "Enter":
                case " ":
                  const modal = new IconSuggestModal(this.plugin, toolbarItem, cb.extraSettingsEl);
                  modal.open();
                  e.preventDefault();
              }
            }
          );
        });
        const s1b = new import_obsidian5.Setting(textFieldsContainer).setClass("note-toolbar-setting-item-field").addText((text) => text.setPlaceholder("Label (optional, if icon set)").setValue(toolbarItem.label).onChange(
          (0, import_obsidian5.debounce)(async (value) => {
            toolbarItem.label = value;
            this.toolbar.updated = new Date().toISOString();
            await this.plugin.saveSettings();
          }, 750)
        ));
        const s1c = new import_obsidian5.Setting(textFieldsContainer).setClass("note-toolbar-setting-item-field").addText((text) => text.setPlaceholder("Tooltip (optional)").setValue(toolbarItem.tooltip).onChange(
          (0, import_obsidian5.debounce)(async (value) => {
            toolbarItem.tooltip = value;
            this.toolbar.updated = new Date().toISOString();
            await this.plugin.saveSettings();
          }, 750)
        ));
        let linkContainer = this.containerEl.createDiv();
        linkContainer.className = "note-toolbar-setting-item-link-container";
        let linkTypeDiv = this.containerEl.createDiv();
        const s1t = new import_obsidian5.Setting(linkTypeDiv).addDropdown(
          (dropdown) => dropdown.addOptions({ command: "Command", file: "File", uri: "URI" }).setValue(toolbarItem.linkAttr.type).onChange(async (value) => {
            toolbarItem.linkAttr.type = value;
            switch (value) {
              case "command":
                toolbarItem.link = "";
                itemLinkFields[index].command.settingEl.setAttribute("data-active", "true");
                itemLinkFields[index].file.settingEl.setAttribute("data-active", "false");
                itemLinkFields[index].uri.settingEl.setAttribute("data-active", "false");
                break;
              case "file":
                itemLinkFields[index].command.settingEl.setAttribute("data-active", "false");
                itemLinkFields[index].file.settingEl.setAttribute("data-active", "true");
                itemLinkFields[index].uri.settingEl.setAttribute("data-active", "false");
                break;
              case "uri":
                itemLinkFields[index].command.settingEl.setAttribute("data-active", "false");
                itemLinkFields[index].file.settingEl.setAttribute("data-active", "false");
                itemLinkFields[index].uri.settingEl.setAttribute("data-active", "true");
                break;
            }
            await this.plugin.saveSettings();
            this.display();
          })
        );
        let linkFieldDiv = this.containerEl.createDiv();
        linkFieldDiv.className = "note-toolbar-setting-item-link-container";
        let linkCommandFieldDiv = this.containerEl.createDiv();
        let linkFileFieldDiv = this.containerEl.createDiv();
        let linkUriFieldDiv = this.containerEl.createDiv();
        let linkFieldHelpDiv = createEl("div");
        linkFieldHelpDiv.addClass("note-toolbar-setting-field-help");
        linkFieldHelpDiv.appendChild(
          learnMoreFr(
            "Tip: Use note properties in URIs.",
            "https://github.com/chrisgurney/obsidian-note-toolbar/wiki/Variables"
          )
        );
        itemLinkFields.push({
          //
          // command
          //
          command: new import_obsidian5.Setting(linkCommandFieldDiv).setClass("note-toolbar-setting-item-field-link").addSearch((cb) => {
            new CommandSuggester(this.app, cb.inputEl);
            cb.setPlaceholder("Search for command").setValue(toolbarItem.link).onChange((0, import_obsidian5.debounce)(async (command) => {
              var _a, _b;
              toolbarItem.link = command;
              toolbarItem.linkAttr.type = "command";
              toolbarItem.linkAttr.commandId = (_b = (_a = cb.inputEl) == null ? void 0 : _a.getAttribute("data-command-id")) != null ? _b : "";
              await this.plugin.saveSettings();
            }, 250));
          }),
          //
          // file
          //
          file: new import_obsidian5.Setting(linkFileFieldDiv).setClass("note-toolbar-setting-item-field-link").addSearch((cb) => {
            new FileSuggester(this.app, cb.inputEl);
            cb.setPlaceholder("Search for file").setValue(toolbarItem.link).onChange((0, import_obsidian5.debounce)(async (value) => {
              var _a;
              toolbarItem.linkAttr.type = "file";
              const file = this.app.vault.getAbstractFileByPath(value);
              if (!(file instanceof import_obsidian5.TFile)) {
                if (document.getElementById("note-toolbar-item-link-note-error") === null) {
                  let errorDiv = this.containerEl.createEl("div", {
                    text: "This file does not exist.",
                    attr: { id: "note-toolbar-item-link-note-error" },
                    cls: "note-toolbar-setting-error-message"
                  });
                  linkContainer.insertAdjacentElement("afterend", errorDiv);
                  itemLinkFields[index].file.settingEl.children[1].addClass("note-toolbar-setting-error");
                }
              } else {
                toolbarItem.link = (0, import_obsidian5.normalizePath)(value);
                toolbarItem.linkAttr.commandId = "";
                (_a = document.getElementById("note-toolbar-item-link-note-error")) == null ? void 0 : _a.remove();
                itemLinkFields[index].file.settingEl.children[1].removeClass("note-toolbar-setting-error");
                await this.plugin.saveSettings();
              }
            }, 750));
          }),
          //
          // URI
          //
          uri: new import_obsidian5.Setting(linkUriFieldDiv).setClass("note-toolbar-setting-item-field-link").addText((text) => text.setPlaceholder("Website, URI, or note title").setValue(toolbarItem.link).onChange(
            (0, import_obsidian5.debounce)(async (value) => {
              toolbarItem.link = value;
              toolbarItem.linkAttr.type = "uri";
              toolbarItem.linkAttr.hasVars = hasVars(value);
              toolbarItem.linkAttr.commandId = "";
              this.toolbar.updated = new Date().toISOString();
              await this.plugin.saveSettings();
            }, 750)
          ).inputEl.insertAdjacentElement("afterend", linkFieldHelpDiv))
        });
        linkFieldDiv.append(itemLinkFields[index].command.settingEl);
        linkFieldDiv.append(itemLinkFields[index].file.settingEl);
        linkFieldDiv.append(itemLinkFields[index].uri.settingEl);
        itemLinkFields[index].command.settingEl.setAttribute(
          "data-active",
          toolbarItem.linkAttr.type === "command" ? "true" : "false"
        );
        itemLinkFields[index].file.settingEl.setAttribute(
          "data-active",
          toolbarItem.linkAttr.type === "file" ? "true" : "false"
        );
        itemLinkFields[index].uri.settingEl.setAttribute(
          "data-active",
          toolbarItem.linkAttr.type === "uri" ? "true" : "false"
        );
        linkContainer.append(linkTypeDiv);
        linkContainer.append(linkFieldDiv);
        let itemControlsContainer = this.containerEl.createDiv();
        itemControlsContainer.className = "note-toolbar-setting-item-controls";
        const s1d = new import_obsidian5.Setting(itemControlsContainer).addExtraButton((cb) => {
          cb.setIcon("up-chevron-glyph").setTooltip("Move up").onClick(async () => this.listMoveHandler(null, this.toolbar.items, index, "up"));
          cb.extraSettingsEl.setAttribute("tabindex", "0");
          this.plugin.registerDomEvent(
            cb.extraSettingsEl,
            "keydown",
            (e) => this.listMoveHandler(e, this.toolbar.items, index, "up")
          );
        }).addExtraButton((cb) => {
          cb.setIcon("down-chevron-glyph").setTooltip("Move down").onClick(async () => this.listMoveHandler(null, this.toolbar.items, index, "down"));
          cb.extraSettingsEl.setAttribute("tabindex", "0");
          this.plugin.registerDomEvent(
            cb.extraSettingsEl,
            "keydown",
            (e) => this.listMoveHandler(e, this.toolbar.items, index, "down")
          );
        }).addExtraButton((cb) => {
          cb.setIcon("trash").setTooltip("Delete").onClick(async () => this.listMoveHandler(null, this.toolbar.items, index, "delete"));
          cb.extraSettingsEl.setAttribute("tabindex", "0");
          this.plugin.registerDomEvent(
            cb.extraSettingsEl,
            "keydown",
            (e) => this.listMoveHandler(e, this.toolbar.items, index, "delete")
          );
        });
        let itemFieldsContainer = this.containerEl.createDiv();
        itemFieldsContainer.className = "note-toolbar-setting-item-fields";
        itemFieldsContainer.appendChild(textFieldsContainer);
        itemTopContainer.appendChild(itemFieldsContainer);
        itemTopContainer.appendChild(linkContainer);
        itemDiv.appendChild(itemTopContainer);
        let visibilityControlsContainer = this.containerEl.createDiv();
        visibilityControlsContainer.className = "note-toolbar-setting-item-visibility-container";
        const visButtons = new import_obsidian5.Setting(visibilityControlsContainer).setClass("note-toolbar-setting-item-visibility").addButton((cb) => {
          let btnIcon = cb.buttonEl.createSpan();
          (0, import_obsidian5.setIcon)(btnIcon, "monitor");
          let [state, tooltip] = this.getPlatformStateLabel(toolbarItem.visibility.desktop, "desktop");
          if (state) {
            let btnLabel = cb.buttonEl.createSpan();
            btnLabel.setText(state);
          }
          cb.setTooltip(tooltip).onClick(async () => {
            var _a, _b;
            (_b = (_a = toolbarItem.visibility).desktop) != null ? _b : _a.desktop = { allViews: { components: [] } };
            let visibilityMenu = this.getItemVisibilityMenu(toolbarItem.visibility.desktop, "desktop");
            visibilityMenu.showAtPosition(getPosition(cb.buttonEl));
          });
        }).addButton((cb) => {
          let btnIcon = cb.buttonEl.createSpan();
          (0, import_obsidian5.setIcon)(btnIcon, "tablet-smartphone");
          let [state, tooltip] = this.getPlatformStateLabel(toolbarItem.visibility.mobile, "mobile");
          if (state) {
            let btnLabel = cb.buttonEl.createSpan();
            btnLabel.setText(state);
          }
          cb.setTooltip(tooltip).onClick(async () => {
            var _a, _b;
            (_b = (_a = toolbarItem.visibility).mobile) != null ? _b : _a.mobile = { allViews: { components: [] } };
            let visibilityMenu = this.getItemVisibilityMenu(toolbarItem.visibility.mobile, "mobile");
            visibilityMenu.showAtPosition(getPosition(cb.buttonEl));
          });
        });
        let itemVisilityAndControlsContainer = this.containerEl.createDiv();
        itemVisilityAndControlsContainer.className = "note-toolbar-setting-item-visibility-and-controls";
        itemVisilityAndControlsContainer.appendChild(visibilityControlsContainer);
        itemVisilityAndControlsContainer.appendChild(itemControlsContainer);
        itemDiv.appendChild(itemVisilityAndControlsContainer);
        itemsListContainer.appendChild(itemDiv);
      }
    );
    new import_obsidian5.Setting(itemsListContainer).setClass("note-toolbar-setting-button").addButton((button) => {
      button.setTooltip("Add a new item to the toolbar").setButtonText("+ Add toolbar item").setCta().onClick(async () => {
        var _a, _b;
        this.toolbar.items.push({
          label: "",
          icon: "",
          link: "",
          linkAttr: {
            commandId: "",
            hasVars: false,
            type: (_b = (_a = this.toolbar.items.last()) == null ? void 0 : _a.linkAttr.type) != null ? _b : "uri"
          },
          tooltip: "",
          visibility: {
            desktop: { allViews: { components: ["icon", "label"] } },
            mobile: { allViews: { components: ["icon", "label"] } },
            tablet: { allViews: { components: ["icon", "label"] } }
          }
        });
        this.toolbar.updated = new Date().toISOString();
        await this.plugin.saveSettings();
        this.display(true);
      });
    });
    itemsContainer.appendChild(itemsListContainer);
    settingsDiv.appendChild(itemsContainer);
  }
  /**
   * Displays the Position setting.
   * @param settingsDiv HTMLElement to add the settings to.
   */
  displayPositionSetting(settingsDiv) {
    var _a, _b;
    new import_obsidian5.Setting(settingsDiv).setName("Position").setDesc(learnMoreFr(
      "Where to position this toolbar.",
      "https://github.com/chrisgurney/obsidian-note-toolbar/wiki/Positioning-toolbars"
    )).setHeading();
    new import_obsidian5.Setting(settingsDiv).setName("Desktop").addDropdown(
      (dropdown) => {
        var _a2, _b2, _c;
        return dropdown.addOptions(
          POSITION_OPTIONS.desktop.reduce((acc, option) => {
            return { ...acc, ...option };
          }, {})
        ).setValue((_c = (_b2 = (_a2 = this.toolbar.position.desktop) == null ? void 0 : _a2.allViews) == null ? void 0 : _b2.position) != null ? _c : "props").onChange(async (val) => {
          this.toolbar.position.desktop = { allViews: { position: val } };
          this.toolbar.updated = new Date().toISOString();
          await this.plugin.saveSettings();
          this.display();
        });
      }
    );
    new import_obsidian5.Setting(settingsDiv).setName("Mobile").setDesc(
      ((_b = (_a = this.toolbar.position.mobile) == null ? void 0 : _a.allViews) == null ? void 0 : _b.position) === "hidden" ? learnMoreFr(
        "Tip: Access toolbars from the navigation bar.",
        "https://github.com/chrisgurney/obsidian-note-toolbar/wiki/Navigation-bar"
      ) : ""
    ).addDropdown(
      (dropdown) => {
        var _a2, _b2, _c;
        return dropdown.addOptions(
          POSITION_OPTIONS.mobile.reduce((acc, option) => {
            return { ...acc, ...option };
          }, {})
        ).setValue((_c = (_b2 = (_a2 = this.toolbar.position.mobile) == null ? void 0 : _a2.allViews) == null ? void 0 : _b2.position) != null ? _c : "props").onChange(async (val) => {
          this.toolbar.position.mobile = { allViews: { position: val } };
          this.toolbar.position.tablet = { allViews: { position: val } };
          this.toolbar.updated = new Date().toISOString();
          await this.plugin.saveSettings();
          this.display();
        });
      }
    );
  }
  /**
   * Displays the Style settings.
   * @param settingsDiv HTMLElement to add the settings to.
   */
  displayStyleSetting(settingsDiv) {
    new import_obsidian5.Setting(settingsDiv).setName("Styles").setDesc(learnMoreFr(
      "List of styles to apply to the toolbar.",
      "https://github.com/chrisgurney/obsidian-note-toolbar/wiki/Styling-toolbars"
    )).setHeading();
    let defaultStyleDiv = this.containerEl.createDiv();
    defaultStyleDiv.className = "note-toolbar-setting-item-style";
    if (this.toolbar.defaultStyles.length == 0) {
      let emptyMsg = this.containerEl.createEl(
        "div",
        { text: emptyMessageFr("No default styles set.") }
      );
      emptyMsg.className = "note-toolbar-setting-empty-message";
      defaultStyleDiv.append(emptyMsg);
    } else {
      this.toolbar.defaultStyles.forEach(
        (style, index) => {
          new import_obsidian5.Setting(defaultStyleDiv).setName(this.getValueForKey(DEFAULT_STYLE_OPTIONS, style)).setTooltip(this.getValueForKey(DEFAULT_STYLE_DISCLAIMERS, style) + "Use in Callout or CSS: " + style).addExtraButton((cb) => {
            cb.setIcon("cross").setTooltip("Remove").onClick(async () => this.listMoveHandler(null, this.toolbar.defaultStyles, index, "delete"));
            cb.extraSettingsEl.setAttribute("tabindex", "0");
            this.plugin.registerDomEvent(
              cb.extraSettingsEl,
              "keydown",
              (e) => this.listMoveHandler(e, this.toolbar.defaultStyles, index, "delete")
            );
          });
        }
      );
    }
    new import_obsidian5.Setting(defaultStyleDiv).addDropdown(
      (dropdown) => dropdown.addOptions(
        DEFAULT_STYLE_OPTIONS.filter((option) => {
          return !this.toolbar.defaultStyles.includes(Object.keys(option)[0]);
        }).reduce((acc, option) => {
          return { ...acc, ...option };
        }, {})
      ).setValue("").onChange(async (val) => {
        if (this.toolbar.defaultStyles.includes(val)) {
          this.toolbar.defaultStyles = this.toolbar.defaultStyles.filter((i) => i !== val);
        } else {
          this.toolbar.defaultStyles.push(val);
        }
        await this.plugin.saveSettings();
        this.display();
      })
    );
    const defaultDesc = document.createDocumentFragment();
    defaultDesc.append("Applies to all platforms unless overridden.");
    defaultDesc.append(this.getStyleDisclaimersFr(DEFAULT_STYLE_DISCLAIMERS, this.toolbar.defaultStyles));
    new import_obsidian5.Setting(settingsDiv).setName("Default").setDesc(defaultDesc).setClass("note-toolbar-setting-item-styles").settingEl.append(defaultStyleDiv);
    let mobileStyleDiv = this.containerEl.createDiv();
    mobileStyleDiv.className = "note-toolbar-setting-item-style";
    if (this.toolbar.mobileStyles.length == 0) {
      let emptyMsg = this.containerEl.createEl(
        "div",
        { text: emptyMessageFr("No mobile styles set.") }
      );
      emptyMsg.className = "note-toolbar-setting-empty-message";
      mobileStyleDiv.append(emptyMsg);
    } else {
      this.toolbar.mobileStyles.forEach(
        (style, index) => {
          new import_obsidian5.Setting(mobileStyleDiv).setName(this.getValueForKey(MOBILE_STYLE_OPTIONS, style)).setTooltip(this.getValueForKey(MOBILE_STYLE_DISCLAIMERS, style) + "Use in Callout or CSS: " + style).addExtraButton((cb) => {
            cb.setIcon("cross").setTooltip("Remove").onClick(async () => this.listMoveHandler(null, this.toolbar.mobileStyles, index, "delete"));
            cb.extraSettingsEl.setAttribute("tabindex", "0");
            this.plugin.registerDomEvent(
              cb.extraSettingsEl,
              "keydown",
              (e) => this.listMoveHandler(e, this.toolbar.mobileStyles, index, "delete")
            );
          });
        }
      );
    }
    new import_obsidian5.Setting(mobileStyleDiv).addDropdown(
      (dropdown) => dropdown.addOptions(
        MOBILE_STYLE_OPTIONS.filter((option) => {
          return !this.toolbar.mobileStyles.includes(Object.keys(option)[0]);
        }).reduce((acc, option) => {
          return { ...acc, ...option };
        }, {})
      ).setValue(this.toolbar.mobileStyles.join(", ") || "").onChange(async (val) => {
        if (this.toolbar.mobileStyles.includes(val)) {
          this.toolbar.mobileStyles = this.toolbar.mobileStyles.filter((i) => i !== val);
        } else {
          this.toolbar.mobileStyles.push(val);
        }
        await this.plugin.saveSettings();
        this.display();
      })
    );
    const mobileDesc = document.createDocumentFragment();
    mobileDesc.append("Override default styles.");
    mobileDesc.append(this.getStyleDisclaimersFr(MOBILE_STYLE_DISCLAIMERS, this.toolbar.mobileStyles));
    new import_obsidian5.Setting(settingsDiv).setName("Mobile").setDesc(mobileDesc).setClass("note-toolbar-setting-item-styles").settingEl.append(mobileStyleDiv);
  }
  /**
   * Displays the Delete button.
   * @param settingsDiv HTMLElement to add the settings to.
   */
  displayDeleteButton(settingsDiv) {
    new import_obsidian5.Setting(settingsDiv).setName("Delete this toolbar").setHeading().setDesc("This action cannot be undone.").setClass("note-toolbar-setting-spaced").addButton((button) => {
      button.setClass("mod-warning").setTooltip("Delete this toolbar").setButtonText("Delete...").setCta().onClick(() => {
        const modal = new DeleteModal(this);
        modal.open();
      });
    });
  }
  /*************************************************************************
   * SETTINGS DISPLAY HANDLERS
   *************************************************************************/
  /**
   * Handles moving items within a list, and deletion, based on click or keyboard event.
   * @param keyEvent KeyboardEvent, if the keyboard is triggering this handler.
   * @param itemArray Array that we're operating on.
   * @param index Number of the item in the list we're moving/deleting.
   * @param action Direction of the move, or "delete".
   */
  async listMoveHandler(keyEvent, itemArray, index, action = void 0) {
    if (keyEvent) {
      switch (keyEvent.key) {
        case "ArrowUp":
          keyEvent.preventDefault();
          action = "up";
          break;
        case "ArrowDown":
          keyEvent.preventDefault();
          action = "down";
          break;
        case "Delete":
        case "Backspace":
          keyEvent.preventDefault();
          action = "delete";
          break;
        case "Enter":
        case " ":
          keyEvent.preventDefault();
          break;
        default:
          return;
      }
    }
    switch (action) {
      case "up":
        arraymove(itemArray, index, index - 1);
        this.toolbar.updated = new Date().toISOString();
        break;
      case "down":
        arraymove(itemArray, index, index + 1);
        this.toolbar.updated = new Date().toISOString();
        break;
      case "delete":
        itemArray.splice(index, 1);
        this.toolbar.updated = new Date().toISOString();
        break;
    }
    await this.plugin.saveSettings();
    this.display();
  }
  /**
   * Remembers the scrolling position of the user and jumps to it on display.
   * @author Taitava (Shell Commands plugin)
   * @link https://github.com/Taitava/obsidian-shellcommands/blob/8d030a23540d587a85bd0dfe2e08c8e6b6b955ab/src/settings/SC_MainSettingsTab.ts#L701 
  */
  rememberLastPosition(containerEl) {
    debugLog("rememberLastPosition:", containerEl);
    containerEl.scrollTo({
      top: this.lastScrollPosition,
      behavior: "auto"
    });
    this.plugin.registerDomEvent(containerEl, "scroll", (event) => {
      this.lastScrollPosition = containerEl.scrollTop;
    });
  }
  /*************************************************************************
   * UTILITIES
   *************************************************************************/
  /**
   * Returns the visibility menu to display, for the given platform.
   * @param platform visibility to check for component visibility
   * @param platformLabel string to show in the menu 
   * @returns Menu
   */
  getItemVisibilityMenu(platform, platformLabel) {
    let isComponentVisible = {
      icon: platform && platform.allViews ? platform.allViews.components.includes("icon") : false,
      label: platform && platform.allViews ? platform.allViews.components.includes("label") : false
    };
    let menu = new import_obsidian5.Menu();
    menu.addItem((menuItem) => {
      menuItem.setTitle(isComponentVisible.icon ? "Icon shows on " + platformLabel : "Icon hidden on " + platformLabel).setIcon("image").setChecked(isComponentVisible.icon).onClick(async (menuEvent) => {
        if (isComponentVisible.icon) {
          removeComponentVisibility(platform, "icon");
          isComponentVisible.icon = false;
        } else {
          addComponentVisibility(platform, "icon");
          isComponentVisible.icon = true;
        }
        this.toolbar.updated = new Date().toISOString();
        await this.plugin.saveSettings();
        this.display();
      });
    });
    menu.addItem((menuItem) => {
      menuItem.setTitle(isComponentVisible.label ? "Label shows on " + platformLabel : "Label hidden on " + platformLabel).setIcon("whole-word").setChecked(isComponentVisible.label).onClick(async (menuEvent) => {
        if (isComponentVisible.label) {
          removeComponentVisibility(platform, "label");
          isComponentVisible.label = false;
        } else {
          addComponentVisibility(platform, "label");
          isComponentVisible.label = true;
        }
        this.toolbar.updated = new Date().toISOString();
        await this.plugin.saveSettings();
        this.display();
      });
    });
    return menu;
  }
  /**
   * Gets the current state of visibility for a given platform.
   * @param platform visibility to check
   * @returns a single word (hidden, visible, or the component name), and a sentence for the tooltip
   */
  getPlatformStateLabel(platform, platformLabel) {
    var _a;
    if (platform && platform.allViews) {
      let dkComponents = (_a = platform.allViews) == null ? void 0 : _a.components;
      if (dkComponents) {
        if (dkComponents.length === 2) {
          return ["", "visible on " + platformLabel];
        } else if (dkComponents.length === 1) {
          return [dkComponents[0], dkComponents[0] + " visible on " + platformLabel];
        } else {
          return ["hidden", "hidden on " + platformLabel];
        }
      }
    }
    return ["hidden", "hidden on " + platformLabel];
  }
  /**
   * Returns a fragment containing any applicable style disclaimers to show, for the provided styles.
   * @param disclaimers List of disclaimers, corresponds with DEFAULT and MOBILE _STYLE_DISCLAIMERS
   * @param stylesToCheck styles that have been applied by the user, to check for applicable disclaimers
   * @returns DocumentFragment with disclaimers to show in settings UI
   */
  getStyleDisclaimersFr(disclaimers, stylesToCheck) {
    let disclaimersFr = document.createDocumentFragment();
    stylesToCheck.forEach((style) => {
      disclaimers.find((disclaimer) => style in disclaimer) ? disclaimersFr.append(disclaimersFr.createEl("br"), "* ", this.getValueForKey(disclaimers, style)) : void 0;
    });
    return disclaimersFr;
  }
  /**
   * Returns the value for the provided key from the provided dictionary.
   * @param dict key-value dictionary
   * @param key string key
   * @returns value from the dictionary
   */
  getValueForKey(dict, key) {
    const option = dict.find((option2) => key in option2);
    return option ? Object.values(option)[0] : "";
  }
};

// src/Settings/Suggesters/FolderSuggester.ts
var import_obsidian6 = require("obsidian");
var FolderSuggester = class extends import_obsidian6.AbstractInputSuggest {
  constructor(app, inputEl) {
    super(app, inputEl);
    this.PATTERN_ALL_FILES = { pattern: "*", label: "*", desc: "all folders" };
    this.PATTERN_ROOT_ONLY = { pattern: "/", label: "/", desc: "root folder only" };
    this.inputEl = inputEl;
  }
  getSuggestions(inputStr) {
    const abstractFiles = this.app.vault.getAllLoadedFiles();
    const folders = [];
    const lowerCaseInputStr = inputStr.toLowerCase();
    folders.push(this.PATTERN_ALL_FILES.pattern);
    abstractFiles.forEach((folder) => {
      if (folder instanceof import_obsidian6.TFolder && folder.path.toLowerCase().contains(lowerCaseInputStr)) {
        folders.push(folder.path);
      }
    });
    return folders;
  }
  renderSuggestion(folder, el) {
    if (folder === this.PATTERN_ALL_FILES.pattern) {
      this.renderPattern(el, this.PATTERN_ALL_FILES);
    } else if (folder === this.PATTERN_ROOT_ONLY.pattern) {
      this.renderPattern(el, this.PATTERN_ROOT_ONLY);
    } else {
      el.setText(folder);
    }
  }
  selectSuggestion(folder) {
    this.inputEl.value = folder;
    this.inputEl.trigger("input");
    this.close();
  }
  /*************************************************************************
   * DISPLAY HELPERS
   *************************************************************************/
  renderPattern(el, suggestion) {
    el.addClass("note-toolbar-setting-folder-suggestion-item-muted");
    el.createSpan().setText(suggestion.label);
    el.createSpan().setText(suggestion.desc);
  }
};

// src/Settings/Suggesters/ToolbarSuggester.ts
var import_obsidian7 = require("obsidian");
var ToolbarSuggester = class extends import_obsidian7.AbstractInputSuggest {
  constructor(app, plugin, inputEl) {
    super(app, inputEl);
    this.plugin = plugin;
    this.inputEl = inputEl;
  }
  getSuggestions(inputStr) {
    const pluginToolbars = this.plugin.settings.toolbars;
    const toolbarSuggestions = [];
    const lowerCaseInputStr = inputStr.toLowerCase();
    pluginToolbars.forEach((toolbar) => {
      if (toolbar.name.toLowerCase().contains(lowerCaseInputStr)) {
        toolbarSuggestions.push(toolbar);
      }
    });
    return toolbarSuggestions;
  }
  renderSuggestion(toolbar, el) {
    el.setText(toolbar.name);
  }
  selectSuggestion(toolbar) {
    this.inputEl.value = toolbar.name;
    this.inputEl.trigger("input");
    this.close();
  }
};

// src/Settings/NoteToolbarSettingTab.ts
var NoteToolbarSettingTab = class extends import_obsidian8.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.app = app;
    this.plugin = plugin;
  }
  openSettingsModal(toolbar) {
    const modal = new ToolbarSettingsModal(this.app, this.plugin, this, toolbar);
    modal.setTitle("Edit Toolbar");
    modal.open();
  }
  /*************************************************************************
   * SETTINGS DISPLAY
   *************************************************************************/
  /**
   * Displays the main settings.
   */
  display(focusOnLastItem = false) {
    const { containerEl } = this;
    containerEl.empty();
    if (this.plugin.settings.version !== SETTINGS_VERSION) {
      new import_obsidian8.Setting(containerEl).setName("\u26A0\uFE0F Error loading plugin: Please reload").setDesc("Old settings file detected. Please restart plugin.").setClass("note-toolbar-setting-plugin-error").setHeading();
    }
    this.displayToolbarList(containerEl);
    new import_obsidian8.Setting(containerEl).setName("Display rules").setDesc(learnMoreFr(
      "Define which notes to display toolbars on.",
      "https://github.com/chrisgurney/obsidian-note-toolbar/wiki/Defining-where-to-show-toolbars"
    )).setHeading();
    this.displayPropertySetting(containerEl);
    this.displayFolderMap(containerEl);
    this.displayMobileSettings(containerEl);
    if (focusOnLastItem) {
      let inputToFocus = this.containerEl.querySelector(
        "#note-toolbar-setting-item-field-" + (this.plugin.settings.folderMappings.length - 1) + ' input[type="search"]'
      );
      if ((inputToFocus == null ? void 0 : inputToFocus.value.length) === 0) {
        inputToFocus.focus();
      }
    }
    this.rememberLastPosition(this.containerEl);
  }
  /**
   * Displays the list of toolbars.
   * @param containerEl HTMLElement to add the settings to.
   */
  displayToolbarList(containerEl) {
    const toolbarsDesc = document.createDocumentFragment();
    toolbarsDesc.append(
      "Define the toolbars you want to add to your notes. ",
      toolbarsDesc.createEl("a", {
        href: "https://github.com/chrisgurney/obsidian-note-toolbar/wiki",
        text: "User Guide"
      }),
      " \u2022\xA0",
      toolbarsDesc.createEl("a", {
        href: "https://github.com/chrisgurney/obsidian-note-toolbar/releases",
        text: "v" + this.plugin.manifest.version
      })
    );
    new import_obsidian8.Setting(containerEl).setName("Toolbars").setDesc(toolbarsDesc).setClass("note-toolbar-setting-no-controls");
    if (this.plugin.settings.toolbars.length == 0) {
      containerEl.createEl("div", { text: emptyMessageFr("Click the button to create a toolbar.") }).className = "note-toolbar-setting-empty-message";
    } else {
      let toolbarListDiv = containerEl.createDiv();
      toolbarListDiv.addClass("note-toolbar-setting-toolbar-list");
      this.plugin.settings.toolbars.forEach(
        (toolbarItem, index) => {
          new import_obsidian8.Setting(toolbarListDiv).setName(toolbarItem.name).setDesc(this.createToolbarPreviewFr(toolbarItem.items)).addButton((button) => {
            button.setTooltip("Update this toolbar's items").setButtonText("Edit").setCta().onClick(() => {
              this.openSettingsModal(toolbarItem);
            });
          });
        }
      );
      containerEl.append(toolbarListDiv);
    }
    new import_obsidian8.Setting(containerEl).setClass("note-toolbar-setting-button").addButton((button) => {
      button.setTooltip("Add a new toolbar").setButtonText("+ New toolbar").setCta().onClick(async () => {
        let newToolbar = {
          defaultStyles: ["border", "even", "sticky"],
          items: [],
          mobileStyles: [],
          name: "",
          position: {
            desktop: { allViews: { position: "props" } },
            mobile: { allViews: { position: "props" } },
            tablet: { allViews: { position: "props" } }
          },
          updated: new Date().toISOString()
        };
        this.plugin.settings.toolbars.push(newToolbar);
        await this.plugin.saveSettings();
        this.openSettingsModal(newToolbar);
      });
    });
  }
  /**
   * Displays the property setting.
   * @param containerEl HTMLElement to add the settings to.
   */
  displayPropertySetting(containerEl) {
    new import_obsidian8.Setting(containerEl).setName("Property").setDesc("If a toolbar name is found in this property, the toolbar will be displayed on the note. Takes precedence over any folder mappings. Set to 'none' to hide the toolbar.").addText((text) => text.setPlaceholder("Property").setValue(this.plugin.settings.toolbarProp).onChange((0, import_obsidian8.debounce)(async (value) => {
      this.plugin.settings.toolbarProp = value;
      await this.plugin.saveSettings();
    }, 750)));
  }
  /**
   * Displays the folder mappings.
   * @param containerEl HTMLElement to add the settings to.
   */
  displayFolderMap(containerEl) {
    new import_obsidian8.Setting(containerEl).setName("Folder mappings").setDesc("Notes in folders below will display the toolbar mapped to it. Precedence is top to bottom.").setClass("note-toolbar-setting-no-border");
    if (this.plugin.settings.folderMappings.length == 0) {
      containerEl.createEl("div", { text: emptyMessageFr("Click the button to create a mapping.") }).className = "note-toolbar-setting-empty-message";
    } else {
      let toolbarFolderListDiv = containerEl.createDiv();
      this.plugin.settings.folderMappings.forEach(
        (mapping, index) => {
          let toolbarFolderListItemDiv = containerEl.createDiv();
          toolbarFolderListItemDiv.className = "note-toolbar-setting-folder-list-item-container";
          let textFieldsDiv = this.containerEl.createDiv();
          textFieldsDiv.id = "note-toolbar-setting-item-field-" + index;
          textFieldsDiv.className = "note-toolbar-setting-item-fields";
          const fs = new import_obsidian8.Setting(textFieldsDiv).setClass("note-toolbar-setting-mapping-field").addSearch((cb) => {
            new FolderSuggester(this.app, cb.inputEl);
            cb.setPlaceholder("Folder").setValue(mapping.folder).onChange((0, import_obsidian8.debounce)(async (newFolder) => {
              var _a;
              if (newFolder && this.plugin.settings.folderMappings.some(
                (mapping2, mapIndex) => {
                  return index != mapIndex ? mapping2.folder.toLowerCase() === newFolder.toLowerCase() : void 0;
                }
              )) {
                if (document.getElementById("note-toolbar-name-error") === null) {
                  let errorDiv = containerEl.createEl("div", {
                    text: "This folder already has a toolbar associated with it.",
                    attr: { id: "note-toolbar-name-error" },
                    cls: "note-toolbar-setting-error-message"
                  });
                  toolbarFolderListItemDiv.insertAdjacentElement("afterend", errorDiv);
                  toolbarFolderListItemDiv.children[0].addClass("note-toolbar-setting-error");
                }
              } else {
                (_a = document.getElementById("note-toolbar-name-error")) == null ? void 0 : _a.remove();
                toolbarFolderListItemDiv.children[0].removeClass("note-toolbar-setting-error");
                this.plugin.settings.folderMappings[index].folder = newFolder ? (0, import_obsidian8.normalizePath)(newFolder) : "";
                await this.plugin.saveSettings();
              }
            }, 250));
          });
          const ts = new import_obsidian8.Setting(textFieldsDiv).setClass("note-toolbar-setting-mapping-field").addSearch((cb) => {
            new ToolbarSuggester(this.app, this.plugin, cb.inputEl);
            cb.setPlaceholder("Toolbar").setValue(mapping.toolbar).onChange((0, import_obsidian8.debounce)(async (newToolbar) => {
              this.plugin.settings.folderMappings[index].toolbar = newToolbar;
              await this.plugin.saveSettings();
            }, 250));
          });
          let itemControlsDiv = this.containerEl.createDiv();
          itemControlsDiv.className = "note-toolbar-setting-item-controls";
          const s1d = new import_obsidian8.Setting(itemControlsDiv).addExtraButton((cb) => {
            cb.setIcon("up-chevron-glyph").setTooltip("Move up").onClick(async () => this.listMoveHandler(null, index, "up"));
            cb.extraSettingsEl.setAttribute("tabindex", "0");
            this.plugin.registerDomEvent(
              cb.extraSettingsEl,
              "keydown",
              (e) => this.listMoveHandler(e, index, "up")
            );
          }).addExtraButton((cb) => {
            cb.setIcon("down-chevron-glyph").setTooltip("Move down").onClick(async () => this.listMoveHandler(null, index, "down"));
            cb.extraSettingsEl.setAttribute("tabindex", "0");
            this.plugin.registerDomEvent(
              cb.extraSettingsEl,
              "keydown",
              (e) => this.listMoveHandler(e, index, "down")
            );
          }).addExtraButton((cb) => {
            cb.setIcon("trash").setTooltip("Delete").onClick(async () => this.listMoveHandler(null, index, "delete"));
            cb.extraSettingsEl.setAttribute("tabindex", "0");
            this.plugin.registerDomEvent(
              cb.extraSettingsEl,
              "keydown",
              (e) => this.listMoveHandler(e, index, "delete")
            );
          });
          toolbarFolderListItemDiv.append(textFieldsDiv);
          toolbarFolderListItemDiv.append(itemControlsDiv);
          toolbarFolderListDiv.append(toolbarFolderListItemDiv);
        }
      );
      containerEl.append(toolbarFolderListDiv);
    }
    new import_obsidian8.Setting(containerEl).setClass("note-toolbar-setting-button").addButton((button) => {
      button.setTooltip("Add a new mapping").setButtonText("+ New mapping").setCta().onClick(async () => {
        let newMapping = {
          folder: "",
          toolbar: ""
        };
        this.plugin.settings.folderMappings.push(newMapping);
        await this.plugin.saveSettings();
        this.display(true);
      });
    });
  }
  /**
   * 
   * @param containerEl 
   */
  displayMobileSettings(containerEl) {
    new import_obsidian8.Setting(containerEl).setName("Mobile settings").setHeading();
    const s1 = new import_obsidian8.Setting(containerEl).setName("Mobile icon").setDesc("Sets the icon for the navigation bar (requires restart) and floating button.").addButton((cb) => {
      cb.setIcon(this.plugin.settings.icon).setTooltip("Select icon").onClick(async (e) => {
        e.preventDefault();
        const modal = new IconSuggestModal(this.plugin, this.plugin.settings, cb.buttonEl);
        modal.open();
      });
      cb.buttonEl.setAttribute("data-note-toolbar-no-icon", !this.plugin.settings.icon ? "true" : "false");
      cb.buttonEl.setAttribute("tabindex", "0");
      this.plugin.registerDomEvent(
        cb.buttonEl,
        "keydown",
        (e) => {
          switch (e.key) {
            case "Enter":
            case " ":
              e.preventDefault();
              const modal = new IconSuggestModal(this.plugin, this.plugin.settings, cb.buttonEl);
              modal.open();
          }
        }
      );
    });
    const s2 = new import_obsidian8.Setting(containerEl).setName("Show 'Edit toolbar' link in toolbar menus").setDesc("Add an item to access the toolbar's settings in the mobile toolbar menu.").addToggle((cb) => {
      cb.setValue(this.plugin.settings.showEditInFabMenu);
      cb.onChange(async (value) => {
        this.plugin.settings.showEditInFabMenu = value;
        this.plugin.saveSettings();
      });
    });
  }
  /*************************************************************************
   * SETTINGS DISPLAY HANDLERS
   *************************************************************************/
  /**
   * Handles moving mappings up and down the list, and deletion, based on click or keyboard event.
   * @param keyEvent KeyboardEvent, if the keyboard is triggering this handler.
   * @param index Number of the item in the list we're moving/deleting.
   * @param action Direction of the move, or "delete".
   */
  async listMoveHandler(keyEvent, index, action) {
    if (keyEvent) {
      switch (keyEvent.key) {
        case "ArrowUp":
          keyEvent.preventDefault();
          action = "up";
          break;
        case "ArrowDown":
          keyEvent.preventDefault();
          action = "down";
          break;
        case "Delete":
        case "Backspace":
          keyEvent.preventDefault();
          action = "delete";
        case "Enter":
        case " ":
          keyEvent.preventDefault();
          break;
        default:
          return;
      }
    }
    switch (action) {
      case "up":
        arraymove(this.plugin.settings.folderMappings, index, index - 1);
        break;
      case "down":
        arraymove(this.plugin.settings.folderMappings, index, index + 1);
        keyEvent == null ? void 0 : keyEvent.preventDefault();
        break;
      case "delete":
        this.plugin.settings.folderMappings.splice(index, 1);
        keyEvent == null ? void 0 : keyEvent.preventDefault();
        break;
    }
    await this.plugin.saveSettings();
    this.display();
  }
  /**
   * Remembers the scrolling position of the user and jumps to it on display.
   * @author Taitava (Shell Commands plugin)
   * @link https://github.com/Taitava/obsidian-shellcommands/blob/8d030a23540d587a85bd0dfe2e08c8e6b6b955ab/src/settings/SC_MainSettingsTab.ts#L701 
  */
  rememberLastPosition(containerEl) {
    debugLog("rememberLastPosition:", containerEl);
    containerEl.scrollTo({
      top: this.lastScrollPosition,
      behavior: "auto"
    });
    this.plugin.registerDomEvent(containerEl, "scroll", (event) => {
      this.lastScrollPosition = containerEl.scrollTop;
    });
  }
  /*************************************************************************
   * UTILITIES
   *************************************************************************/
  /**
   * Constructs a preview of the given toolbar, including the icons used.
   * @param toolbarItems Array of ToolbarItemSettings to display in the preview.
   * @returns DocumentFragment
   */
  createToolbarPreviewFr(toolbarItems) {
    let toolbarFr = document.createDocumentFragment();
    if (toolbarItems.length > 0) {
      toolbarItems.filter((item) => {
        return item.label === "" && item.icon === "" ? false : true;
      }).map((item) => {
        let itemFr = toolbarFr.createDiv();
        itemFr.addClass("note-toolbar-setting-toolbar-list-preview-item");
        let iconFr = toolbarFr.createSpan();
        let labelFr = toolbarFr.createSpan();
        if (item.icon) {
          (0, import_obsidian8.setIcon)(iconFr, item.icon);
          toolbarFr.append(iconFr);
        }
        if (item.label) {
          labelFr.textContent = item.label;
          toolbarFr.append(labelFr);
        }
        itemFr.append(iconFr, labelFr);
        toolbarFr.append(itemFr);
      });
    } else {
      toolbarFr = emptyMessageFr("No toolbar items. Click Edit to update this toolbar.");
    }
    return toolbarFr;
  }
};

// src/main.ts
var NoteToolbarPlugin = class extends import_obsidian9.Plugin {
  constructor() {
    super(...arguments);
    /* keeping for potential future use
    	async storeLeafId(currentView: MarkdownView) {
    		// @ts-ignore
    		this.activeLeafIds.push(currentView?.file?.path + '_' + currentView?.leaf.id);
    	}
    
    	haveLeafId(currentView: MarkdownView): boolean {
    		// @ts-ignore
    		return this.activeLeafIds.contains(currentView?.file?.path + '_' + currentView?.leaf.id);
    	}
    
    	async removeLeafId(idToRemove: string) {
    		// not sure when to call this; can't find event that's fired when leaf closes
    		this.activeLeafIds.remove(idToRemove);
    	}
    	*/
    /*************************************************************************
     * LISTENERS
     *************************************************************************/
    /**
     * On opening of a file, check and render toolbar if necessary.
     * @param file TFile that was opened.
     */
    this.fileOpenListener = (file) => {
      var _a;
      if (file != null) {
        debugLog("file-open: " + file.name);
        this.checkAndRenderToolbar(file, (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter);
      }
    };
    /**
     * On layout changes, delete, check and render toolbar if necessary.
     */
    this.layoutChangeListener = () => {
      let currentView = this.app.workspace.getActiveViewOfType(import_obsidian9.MarkdownView);
      let viewMode = currentView == null ? void 0 : currentView.getMode();
      debugLog("===== LAYOUT-CHANGE ===== ", viewMode);
      switch (viewMode) {
        case "source":
        case "preview":
          debugLog("layout-change: ", viewMode, " -> re-rendering toolbar");
          let toolbarEl = this.getToolbarEl();
          let toolbarPos = toolbarEl == null ? void 0 : toolbarEl.getAttribute("data-tbar-position");
          debugLog("layout-change: position: ", toolbarPos);
          toolbarPos === "props" ? this.removeActiveToolbar() : void 0;
          this.app.workspace.onLayoutReady((0, import_obsidian9.debounce)(() => {
            debugLog("LAYOUT READY");
            this.renderToolbarForActiveFile();
          }, viewMode === "preview" ? 200 : 0));
          break;
        default:
          return;
      }
    };
    /**
     * On leaf changes, delete, check and render toolbar if necessary. 
     */
    this.leafChangeListener = (event) => {
      var _a;
      let currentView = this.app.workspace.getActiveViewOfType(import_obsidian9.MarkdownView);
      let viewMode = currentView == null ? void 0 : currentView.getMode();
      debugLog("===== LEAF-CHANGE ===== ", viewMode, event);
      debugLog((_a = currentView == null ? void 0 : currentView.file) == null ? void 0 : _a.path, currentView == null ? void 0 : currentView.leaf.id);
      switch (viewMode) {
        case "source":
        case "preview":
          debugLog("leaf-change: ", viewMode, " -> re-rendering toolbar");
          this.removeActiveToolbar();
          this.renderToolbarForActiveFile();
          break;
        default:
          return;
      }
    };
    /**
     * On changes to metadata, trigger the checks and rendering of a toolbar if necessary.
     * @param file TFile in which metadata changed.
     * @param data ??? (not used)
     * @param cache CachedMetadata, from which we look at the frontmatter.
     */
    this.metadataCacheListener = (file, data, cache) => {
      debugLog("metadata-changed: " + file.name);
      if (this.app.workspace.getActiveFile() === file) {
        this.checkAndRenderToolbar(file, cache.frontmatter);
      }
    };
  }
  /**
   * When this plugin is loaded (e.g., on Obsidian startup, or plugin is enabled in settings):
   * adds listeners, settings, and renders the toolbar for the active file.
   */
  async onload() {
    await this.loadSettings();
    this.registerEvent(this.app.workspace.on("active-leaf-change", this.leafChangeListener));
    this.registerEvent(this.app.metadataCache.on("changed", this.metadataCacheListener));
    this.registerEvent(this.app.workspace.on("layout-change", this.layoutChangeListener));
    this.addCommand({ id: "focus", name: "Focus", callback: async () => this.focusCommand() });
    this.addCommand({ id: "open-settings", name: "Open Plugin Settings", callback: async () => this.openSettingsCommand() });
    this.addCommand({ id: "open-toolbar-settings", name: "Open Toolbar Settings", callback: async () => this.openToolbarSettingsCommand() });
    this.addCommand({ id: "show-properties", name: "Show Properties", callback: async () => this.togglePropsCommand("show") });
    this.addCommand({ id: "hide-properties", name: "Hide Properties", callback: async () => this.togglePropsCommand("hide") });
    this.addCommand({ id: "toggle-properties", name: "Toggle Properties", callback: async () => this.togglePropsCommand("toggle") });
    (0, import_obsidian9.addIcon)("note-toolbar-empty", '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" class="svg-icon note-toolbar-empty\u201D></svg>');
    if (import_obsidian9.Platform.isMobile) {
      debugLog("isMobile");
      this.addRibbonIcon(this.settings.icon, "Note Toolbar", (event) => {
        var _a;
        let activeFile = this.app.workspace.getActiveFile();
        if (activeFile) {
          let frontmatter = activeFile ? (_a = this.app.metadataCache.getFileCache(activeFile)) == null ? void 0 : _a.frontmatter : void 0;
          let toolbar = this.getMatchingToolbar(frontmatter, activeFile);
          if (toolbar) {
            this.renderToolbarAsMenu(toolbar).then((menu) => {
              menu.showAtPosition(event);
            });
          }
        }
      });
    }
    this.addSettingTab(new NoteToolbarSettingTab(this.app, this));
    this.app.workspace.trigger("parse-style-settings");
    debugLog("LOADED");
    this.app.workspace.onLayoutReady(() => {
      debugLog("onload: rendering initial toolbar");
      this.renderToolbarForActiveFile();
    });
  }
  /**
   * When this plugin is unloaded (e.g., disabled in settings, or Obsidian is restarted):
   * removes all toolbars.
   */
  async onunload() {
    this.removeAllToolbars();
    debugLog("UNLOADED");
  }
  /*************************************************************************
   * TOOLBAR RENDERERS
   *************************************************************************/
  /**
   * Checks if the provided file and frontmatter meets the criteria to render a toolbar,
   * or if we need to remove the toolbar if it shouldn't be there.
   * @param file TFile (note) to check if we need to create a toolbar.
   * @param frontmatter FrontMatterCache to check if there's a prop for the toolbar.
   */
  async checkAndRenderToolbar(file, frontmatter) {
    debugLog("checkAndRenderToolbar()");
    let matchingToolbar = this.getMatchingToolbar(frontmatter, file);
    let toolbarRemoved = this.removeToolbarIfNeeded(matchingToolbar);
    if (matchingToolbar && toolbarRemoved) {
      debugLog("-- RENDERING TOOLBAR: ", matchingToolbar, " for file: ", file);
      this.renderToolbar(matchingToolbar);
    }
  }
  /**
   * Get toolbar for the given frontmatter (based on a toolbar prop), and failing that the file (based on folder mappings).
   * @param frontmatter FrontMatterCache to check if there's a prop for the toolbar.
   * @param file The note to check if we have a toolbar for.
   * @returns ToolbarSettings or undefined, if there is no matching toolbar.
   */
  getMatchingToolbar(frontmatter, file) {
    var _a, _b;
    debugLog("getMatchingToolbar()");
    let matchingToolbar = void 0;
    const propName = this.settings.toolbarProp;
    let ignoreToolbar = false;
    const notetoolbarProp = (_a = frontmatter == null ? void 0 : frontmatter[propName]) != null ? _a : null;
    if (notetoolbarProp !== null) {
      notetoolbarProp.includes("none") ? ignoreToolbar = true : false;
      ignoreToolbar ? void 0 : matchingToolbar = this.getToolbarSettingsFromProps(notetoolbarProp);
    }
    if (!matchingToolbar && !ignoreToolbar) {
      let mapping;
      let filePath;
      for (let index = 0; index < this.settings.folderMappings.length; index++) {
        mapping = this.settings.folderMappings[index];
        filePath = ((_b = file.parent) == null ? void 0 : _b.path) === "/" ? "/" : file.path.toLowerCase();
        if (["*"].includes(mapping.folder) || filePath.toLowerCase().startsWith(mapping.folder.toLowerCase())) {
          matchingToolbar = this.getToolbarSettings(mapping.toolbar);
          if (matchingToolbar) {
            break;
          }
        }
      }
    }
    return matchingToolbar;
  }
  /**
   * Renders the toolbar for the provided toolbar settings.
   * @param toolbar ToolbarSettings
   */
  async renderToolbar(toolbar) {
    var _a, _b, _c, _d, _e, _f;
    debugLog("renderToolbar: ", toolbar);
    let position;
    import_obsidian9.Platform.isMobile ? position = (_c = (_b = (_a = toolbar.position.mobile) == null ? void 0 : _a.allViews) == null ? void 0 : _b.position) != null ? _c : "props" : position = (_f = (_e = (_d = toolbar.position.desktop) == null ? void 0 : _d.allViews) == null ? void 0 : _e.position) != null ? _f : "props";
    let noteToolbarElement;
    let embedBlock = activeDocument.createElement("div");
    embedBlock.addClass("cg-note-toolbar-container");
    embedBlock.setAttribute("data-tbar-position", position);
    switch (position) {
      case "fabl":
      case "fabr":
        noteToolbarElement = await this.renderToolbarAsFab(toolbar);
        position === "fabl" ? noteToolbarElement.setAttribute("data-fab-position", "left") : void 0;
        embedBlock.append(noteToolbarElement);
        this.registerDomEvent(embedBlock, "click", (e) => this.toolbarFabHandler(e, noteToolbarElement));
        break;
      case "props":
      case "top":
        noteToolbarElement = await this.renderToolbarAsCallout(toolbar);
        let div = activeDocument.createElement("div");
        div.append(noteToolbarElement);
        embedBlock.addClasses(["cm-embed-block", "cm-callout", "cg-note-toolbar-bar-container"]);
        embedBlock.append(div);
        embedBlock.oncontextmenu = (e) => this.toolbarContextMenuHandler(e);
        this.registerDomEvent(embedBlock, "keydown", (e) => this.toolbarKeyboardHandler(e));
        break;
      case "hidden":
      default:
        break;
    }
    embedBlock.setAttribute("data-name", toolbar.name);
    embedBlock.setAttribute("data-updated", toolbar.updated);
    let currentView = this.app.workspace.getActiveViewOfType(import_obsidian9.MarkdownView);
    switch (position) {
      case "fabl":
      case "fabr":
        currentView == null ? void 0 : currentView.containerEl.appendChild(embedBlock);
        break;
      case "top":
        embedBlock.addClass("cg-note-toolbar-position-top");
        let viewHeader = currentView == null ? void 0 : currentView.containerEl.querySelector(".view-header");
        viewHeader ? viewHeader.insertAdjacentElement("afterend", embedBlock) : debugLog("\u{1F6D1} renderToolbarFromSettings: Unable to find .view-header to insert toolbar");
        break;
      case "hidden":
      case "props":
      default:
        let propsEl = this.getPropsEl();
        if (!propsEl) {
          debugLog("\u{1F6D1} renderToolbarFromSettings: Unable to find .metadata-container to insert toolbar");
        }
        propsEl == null ? void 0 : propsEl.insertAdjacentElement("afterend", embedBlock);
        break;
    }
  }
  /**
   * Renders the given toolbar as a callout (to add to the container) and returns it.
   * @param toolbar
   * @returns HTMLElement cg-note-toolbar-callout
   */
  async renderToolbarAsCallout(toolbar) {
    let noteToolbarUl = activeDocument.createElement("ul");
    noteToolbarUl.setAttribute("role", "menu");
    toolbar.items.filter((item) => {
      return item.label === "" && item.icon === "" ? false : true;
    }).map((item) => {
      let toolbarItem = activeDocument.createElement("span");
      toolbarItem.className = "external-link";
      toolbarItem.setAttribute("href", item.link);
      toolbarItem.setAttribute("role", "link");
      toolbarItem.tabIndex = 0;
      Object.entries(item.linkAttr).forEach(([key, value]) => {
        toolbarItem.setAttribute(`data-toolbar-link-attr-${key}`, value);
      });
      item.tooltip ? (0, import_obsidian9.setTooltip)(toolbarItem, item.tooltip, { placement: "top" }) : void 0;
      toolbarItem.setAttribute("rel", "noopener");
      toolbarItem.onclick = (e) => this.toolbarClickHandler(e);
      const [dkHasIcon, dkHasLabel, mbHasIcon, mbHasLabel, tabHasIcon, tabHasLabel] = calcComponentVisToggles(item.visibility);
      if (item.label) {
        if (item.icon) {
          let itemIcon = toolbarItem.createSpan();
          this.setComponentDisplayClass(itemIcon, dkHasIcon, mbHasIcon);
          (0, import_obsidian9.setIcon)(itemIcon, item.icon);
          let itemLabel = toolbarItem.createSpan();
          this.setComponentDisplayClass(itemLabel, dkHasLabel, mbHasLabel);
          itemLabel.innerText = item.label;
        } else {
          this.setComponentDisplayClass(toolbarItem, dkHasLabel, mbHasLabel);
          toolbarItem.innerText = item.label;
        }
      } else {
        this.setComponentDisplayClass(toolbarItem, dkHasIcon, mbHasIcon);
        (0, import_obsidian9.setIcon)(toolbarItem, item.icon);
      }
      let noteToolbarLi = activeDocument.createElement("li");
      const [showOnDesktop, showOnMobile, showOnTablet] = calcItemVisToggles(item.visibility);
      !showOnMobile ? noteToolbarLi.addClass("hide-on-mobile") : false;
      !showOnDesktop ? noteToolbarLi.addClass("hide-on-desktop") : false;
      noteToolbarLi.append(toolbarItem);
      noteToolbarUl.appendChild(noteToolbarLi);
    });
    let noteToolbarCallout = activeDocument.createElement("div");
    if (toolbar.items.length > 0) {
      let noteToolbarCalloutContent = activeDocument.createElement("div");
      noteToolbarCalloutContent.className = "callout-content";
      noteToolbarCalloutContent.append(noteToolbarUl);
      noteToolbarCallout.className = "callout cg-note-toolbar-callout";
      noteToolbarCallout.setAttribute("data-callout", "note-toolbar");
      noteToolbarCallout.setAttribute("data-callout-metadata", [...toolbar.defaultStyles, ...toolbar.mobileStyles].join("-"));
      noteToolbarCallout.append(noteToolbarCalloutContent);
    }
    return noteToolbarCallout;
  }
  /**
   * 
   * @param toolbar 
   * @returns HTMLElement cg-note-toolbar-fab
   */
  async renderToolbarAsFab(toolbar) {
    let noteToolbarFabContainer = activeDocument.createElement("div");
    noteToolbarFabContainer.addClass("cg-note-toolbar-fab-container");
    noteToolbarFabContainer.setAttribute("role", "group");
    noteToolbarFabContainer.setAttribute("aria-label", "Note Toolbar button");
    let noteToolbarFabButton = activeDocument.createElement("button");
    noteToolbarFabButton.addClass("cg-note-toolbar-fab");
    noteToolbarFabButton.setAttribute("title", "Open Note Toolbar");
    noteToolbarFabButton.setAttribute("aria-label", "Open Note Toolbar");
    (0, import_obsidian9.setIcon)(noteToolbarFabButton, this.settings.icon);
    noteToolbarFabContainer.append(noteToolbarFabButton);
    return noteToolbarFabContainer;
  }
  /**
   * Renders the given toolbar as a menu and returns it.
   * @param toolbar 
   * @returns Menu with toolbar's items
   */
  async renderToolbarAsMenu(toolbar) {
    let menu = new import_obsidian9.Menu();
    toolbar.items.forEach((toolbarItem, index) => {
      const [showOnDesktop, showOnMobile, showOnTablet] = calcItemVisToggles(toolbarItem.visibility);
      if (showOnMobile) {
        menu.addItem((item) => {
          item.setIcon(toolbarItem.icon ? toolbarItem.icon : "note-toolbar-empty").setTitle(toolbarItem.label ? toolbarItem.label : toolbarItem.tooltip).onClick(async (menuEvent) => {
            debugLog(toolbarItem.link, toolbarItem.linkAttr, toolbarItem.contexts);
            await this.handleLink(toolbarItem.link, toolbarItem.linkAttr);
          });
        });
      }
    });
    if (this.settings.showEditInFabMenu) {
      menu.addSeparator();
      menu.addItem((item) => {
        item.setTitle("Edit toolbar: " + toolbar.name + "...").setIcon("lucide-pen-box").onClick((menuEvent) => {
          const modal = new ToolbarSettingsModal(this.app, this, null, toolbar);
          modal.setTitle("Edit Toolbar: " + toolbar.name);
          modal.open();
        });
      });
    }
    return menu;
  }
  /**
   * Creates the toolbar in the active file (assuming it needs one).
   */
  async renderToolbarForActiveFile() {
    var _a;
    let activeFile = this.app.workspace.getActiveFile();
    if (activeFile) {
      let frontmatter = activeFile ? (_a = this.app.metadataCache.getFileCache(activeFile)) == null ? void 0 : _a.frontmatter : void 0;
      this.checkAndRenderToolbar(activeFile, frontmatter);
    }
  }
  /**
   * Sets the appropriate class on the given component, based on its visibility settings.
   * @param element HTMLElement to set the display class on
   * @param dkVisible true if component is visible on desktop
   * @param mbVisibile true if component is visible on mobile
   */
  setComponentDisplayClass(element, dkVisible, mbVisibile) {
    if (!dkVisible && !mbVisibile) {
      element.addClass("hide");
    } else {
      !dkVisible && element.addClass("hide-on-desktop");
      !mbVisibile && element.addClass("hide-on-mobile");
    }
  }
  /*************************************************************************
   * COMMANDS
   *************************************************************************/
  /**
   * Sets the focus on the first item in the toolbar.
   */
  async focusCommand() {
    debugLog("focusCommand()");
    let toolbarEl = this.getToolbarEl();
    let toolbarPosition = toolbarEl == null ? void 0 : toolbarEl.getAttribute("data-tbar-position");
    switch (toolbarPosition) {
      case "fabr":
      case "fabl":
        let toolbarFab = toolbarEl == null ? void 0 : toolbarEl.querySelector("button.cg-note-toolbar-fab");
        debugLog("focusCommand: button: ", toolbarFab);
        toolbarFab.click();
        break;
      case "props":
      case "top":
        let itemsUl = this.getToolbarListEl();
        if (itemsUl) {
          debugLog("focusCommand: toolbar: ", itemsUl);
          let items = Array.from(itemsUl.children);
          const visibleItems = items.filter((item) => {
            return window.getComputedStyle(item).getPropertyValue("display") !== "none";
          });
          const link = visibleItems[0] ? visibleItems[0].querySelector("span") : null;
          debugLog("focusCommand: focussed item: ", link);
          link == null ? void 0 : link.focus();
        }
        break;
      case "hidden":
      default:
        break;
    }
  }
  /**
   * Convenience command to open Note Toolbar's settings.
   */
  async openSettingsCommand() {
    const settings = this.app.setting;
    settings.open();
    settings.openTabById("note-toolbar");
  }
  /**
   * Convenience command to open this toolbar's settings.
   */
  async openToolbarSettingsCommand() {
    let toolbarEl = this.getToolbarEl();
    let toolbarName = toolbarEl == null ? void 0 : toolbarEl.getAttribute("data-name");
    let toolbarSettings = toolbarName ? this.getToolbarSettings(toolbarName) : void 0;
    if (toolbarSettings) {
      const modal = new ToolbarSettingsModal(this.app, this, null, toolbarSettings);
      modal.setTitle("Edit Toolbar: " + toolbarName);
      modal.open();
    }
  }
  /**
   * Shows, completely hides, or toggles the visibility of this note's Properties.
   * @param visibility Set to 'show', 'hide', or 'toggle'
   */
  async togglePropsCommand(visibility) {
    let propsEl = this.getPropsEl();
    let currentView = this.app.workspace.getActiveViewOfType(import_obsidian9.MarkdownView);
    debugLog("togglePropsCommand: ", "visibility: ", visibility, "props: ", propsEl);
    if (propsEl && !currentView.editMode.sourceMode) {
      let propsDisplayStyle = getComputedStyle(propsEl).getPropertyValue("display");
      visibility === "toggle" ? propsDisplayStyle === "none" ? visibility = "show" : visibility = "hide" : void 0;
      switch (visibility) {
        case "show":
          propsEl.style.display = "var(--metadata-display-editing)";
          if (propsEl.classList.contains("is-collapsed")) {
            propsEl.querySelector(".metadata-properties-heading").click();
          }
          break;
        case "hide":
          propsEl.style.display = "none";
          break;
      }
    }
  }
  /*************************************************************************
   * HANDLERS
   *************************************************************************/
  /**
   * Handles the floating action button specifically on mobile.
   * @param event MouseEvent
   * @param posAtElement HTMLElement to position the menu at, which might be different from where the event originated
   */
  async toolbarFabHandler(event, posAtElement) {
    var _a;
    debugLog("toolbarFabHandler: ", event);
    event.preventDefault();
    let activeFile = this.app.workspace.getActiveFile();
    if (activeFile) {
      let frontmatter = activeFile ? (_a = this.app.metadataCache.getFileCache(activeFile)) == null ? void 0 : _a.frontmatter : void 0;
      let toolbar = this.getMatchingToolbar(frontmatter, activeFile);
      if (toolbar) {
        this.renderToolbarAsMenu(toolbar).then((menu) => {
          let elemRect = posAtElement.getBoundingClientRect();
          menu.showAtPosition({
            x: elemRect.x,
            y: elemRect.bottom,
            width: elemRect.width,
            overlap: true,
            left: true
          });
        });
      }
    }
  }
  /**
   * Handles keyboard navigation within the toolbar.
   * @param e KeyboardEvent
   */
  async toolbarKeyboardHandler(e) {
    var _a, _b, _c;
    debugLog("toolbarKeyboardHandler: ", e);
    let itemsUl = this.getToolbarListEl();
    if (itemsUl) {
      e.key ? ["ArrowRight", "ArrowDown", "ArrowLeft", "ArrowUp", "Enter", " "].includes(e.key) ? e.preventDefault() : void 0 : void 0;
      let items = Array.from(itemsUl.children);
      const visibleItems = items.filter((item) => {
        return window.getComputedStyle(item).getPropertyValue("display") !== "none";
      });
      let currentIndex = visibleItems.indexOf((_a = activeDocument.activeElement) == null ? void 0 : _a.parentElement);
      switch (e.key) {
        case "ArrowRight":
        case "ArrowDown":
          const nextIndex = (currentIndex + 1) % visibleItems.length;
          (_b = visibleItems[nextIndex].querySelector("span")) == null ? void 0 : _b.focus();
          break;
        case "ArrowLeft":
        case "ArrowUp":
          const prevIndex = (currentIndex - 1 + visibleItems.length) % visibleItems.length;
          (_c = visibleItems[prevIndex].querySelector("span")) == null ? void 0 : _c.focus();
          break;
        case "Enter":
        case " ":
          (activeDocument == null ? void 0 : activeDocument.activeElement).click();
          break;
        case "Escape":
          let currentView = this.app.workspace.getActiveViewOfType(import_obsidian9.MarkdownView);
          let viewMode = currentView == null ? void 0 : currentView.getMode();
          if (viewMode === "preview") {
            (activeDocument == null ? void 0 : activeDocument.activeElement).blur();
          }
          break;
      }
    }
  }
  /**
   * On click of an item in the toolbar, we replace any variables that might
   * be in the URL, and then open it.
   * @param e MouseEvent
   */
  async toolbarClickHandler(e) {
    debugLog("toolbarClickHandler: ", e);
    let clickedEl = e.currentTarget;
    let linkHref = clickedEl.getAttribute("href");
    if (linkHref != null) {
      let linkType = clickedEl.getAttribute("data-toolbar-link-attr-type");
      linkType ? ["command", "file", "uri"].includes(linkType) ? e.preventDefault() : void 0 : void 0;
      debugLog("toolbarClickHandler: ", "clickedEl: ", clickedEl);
      let linkHasVars = clickedEl.getAttribute("data-toolbar-link-attr-hasVars") ? clickedEl.getAttribute("data-toolbar-link-attr-hasVars") === "true" : true;
      let linkCommandId = clickedEl.getAttribute("data-toolbar-link-attr-commandid");
      if ((e == null ? void 0 : e.pointerType) === "mouse") {
        clickedEl.blur();
      }
      this.handleLink(linkHref, { commandId: linkCommandId, hasVars: linkHasVars, type: linkType });
    }
  }
  /**
   * Handles the link provided.
   * @param linkHref What the link is for.
   * @param linkAttr Attributes of the link.
   */
  async handleLink(linkHref, linkAttr) {
    var _a, _b, _c, _d;
    if (linkAttr.hasVars) {
      let activeFile = this.app.workspace.getActiveFile();
      linkHref = this.replaceVars(linkHref, activeFile, false);
      debugLog("- uri vars replaced: ", linkHref);
    }
    switch (linkAttr.type) {
      case "command":
        debugLog("- executeCommandById: ", linkAttr.commandId);
        linkAttr.commandId ? this.app.commands.executeCommandById(linkAttr.commandId) : void 0;
        break;
      case "file":
        let activeFile = (_b = (_a = this.app.workspace.getActiveFile()) == null ? void 0 : _a.path) != null ? _b : "";
        debugLog("- openLinkText: ", linkHref, " from: ", activeFile);
        this.app.workspace.openLinkText(linkHref, activeFile);
        break;
      case "uri":
        if (isValidUri(linkHref)) {
          window.open(linkHref, "_blank");
        } else {
          let activeFile2 = (_d = (_c = this.app.workspace.getActiveFile()) == null ? void 0 : _c.path) != null ? _d : "";
          this.app.workspace.openLinkText(linkHref, activeFile2);
        }
        break;
    }
    if (false) {
      if (href.toLowerCase().startsWith("onclick:")) {
        let functionName = href.slice(8);
        if (typeof window[functionName] === "function") {
          window[functionName]();
        }
      }
    }
  }
  /**
   * Shows a context menu with links to settings/configuration.
   * @param e MouseEvent
   */
  async toolbarContextMenuHandler(e) {
    var _a, _b, _c, _d;
    e.preventDefault();
    let toolbarEl = e.target.closest(".cg-note-toolbar-container");
    let toolbarName = toolbarEl == null ? void 0 : toolbarEl.getAttribute("data-name");
    let toolbarSettings = toolbarName ? this.getToolbarSettings(toolbarName) : void 0;
    let contextMenu = new import_obsidian9.Menu();
    if (toolbarSettings !== void 0) {
      contextMenu.addItem((item) => {
        item.setTitle("Edit toolbar: " + toolbarName + "...").setIcon("lucide-pen-box").onClick((menuEvent) => {
          const modal = new ToolbarSettingsModal(this.app, this, null, toolbarSettings);
          modal.setTitle("Edit Toolbar: " + toolbarName);
          modal.open();
        });
      });
    }
    contextMenu.addItem((item) => {
      item.setTitle("Note Toolbar settings...").setIcon("lucide-wrench").onClick((menuEvent) => {
        this.openSettingsCommand();
      });
    });
    if (toolbarSettings !== void 0) {
      let currentPosition;
      let platform;
      if (import_obsidian9.Platform.isDesktop) {
        currentPosition = (_b = (_a = toolbarSettings.position.desktop) == null ? void 0 : _a.allViews) == null ? void 0 : _b.position;
        platform = "desktop";
      } else if (import_obsidian9.Platform.isMobile) {
        currentPosition = (_d = (_c = toolbarSettings.position.mobile) == null ? void 0 : _c.allViews) == null ? void 0 : _d.position;
        platform = "mobile";
      }
      if (platform !== void 0 && (currentPosition === "props" || currentPosition === "top")) {
        contextMenu.addSeparator();
        contextMenu.addItem((item) => {
          item.setTitle(currentPosition === "props" ? "Set position: Top (fixed)" : "Set position: Below Properties").setIcon(currentPosition === "props" ? "arrow-up-to-line" : "arrow-down-narrow-wide").onClick((menuEvent) => {
            let newPosition = currentPosition === "props" ? "top" : "props";
            if (toolbarSettings == null ? void 0 : toolbarSettings.position) {
              platform === "desktop" ? toolbarSettings.position.desktop = { allViews: { position: newPosition } } : toolbarSettings.position.mobile = { allViews: { position: newPosition } };
              toolbarSettings.updated = new Date().toISOString();
              this.saveSettings();
            }
          });
        });
      }
    }
    contextMenu.showAtPosition(e);
  }
  /**
   * Replace variables in the given string of the format {{variablename}}, with metadata from the file.
   * @param s String to replace the variables in.
   * @param file File with the metadata (name, frontmatter) we'll use to fill in the variables.
   * @param encode True if we should encode the variables (recommended if part of external URL).
   * @returns String with the variables replaced.
   */
  replaceVars(s, file, encode) {
    var _a;
    let noteTitle = file == null ? void 0 : file.basename;
    if (noteTitle != null) {
      s = s.replace("{{note_title}}", encode ? encodeURIComponent(noteTitle) : noteTitle);
    }
    let frontmatter = file ? (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter : void 0;
    if (frontmatter) {
      s = s.replace(/{{prop_(.*?)}}/g, (match, p1) => {
        const key = p1.trim();
        if (frontmatter && frontmatter[key] !== void 0) {
          let fm = Array.isArray(frontmatter[key]) ? frontmatter[key].join(",") : frontmatter[key];
          const linkWrap = /\[\[|\]\]/g;
          return encode ? encodeURIComponent(fm.replace(linkWrap, "")) : fm.replace(linkWrap, "");
        } else {
          return "";
        }
      });
    }
    return s;
  }
  /*************************************************************************
   * ELEMENT GETTERS
   *************************************************************************/
  /**
   * Gets the Properties container in the current view.
   * @returns HTMLElement or null, if it doesn't exist.
   */
  getPropsEl() {
    let currentView = this.app.workspace.getActiveViewOfType(import_obsidian9.MarkdownView);
    let propertiesContainer = activeDocument.querySelector(".workspace-leaf.mod-active .markdown-" + (currentView == null ? void 0 : currentView.getMode()) + "-view .metadata-container");
    debugLog("getPropsEl: ", ".workspace-leaf.mod-active .markdown-" + (currentView == null ? void 0 : currentView.getMode()) + "-view .metadata-container");
    return propertiesContainer;
  }
  /**
   * Get the toolbar element, in the current view.
   * @param positionsToCheck 
   * @returns HTMLElement or null, if it doesn't exist.
   */
  getToolbarEl() {
    let existingToolbarEl = activeDocument.querySelector(".workspace-leaf.mod-active .cg-note-toolbar-container");
    debugLog("getToolbarEl: ", existingToolbarEl);
    return existingToolbarEl;
  }
  /**
   * Get the toolbar element's <ul> element, in the current view.
   * @returns HTMLElement or null, if it doesn't exist.
   */
  getToolbarListEl() {
    let itemsUl = activeDocument.querySelector(".workspace-leaf.mod-active .cg-note-toolbar-container .callout-content > ul");
    return itemsUl;
  }
  /*************************************************************************
   * TOOLBAR REMOVAL
   *************************************************************************/
  /**
   * Remove the toolbar on the active file.
   */
  async removeActiveToolbar() {
    let existingToolbar = activeDocument.querySelector(".workspace-leaf.mod-active .cg-note-toolbar-container");
    debugLog("removeActiveToolbar: existingToolbar: ", existingToolbar);
    existingToolbar == null ? void 0 : existingToolbar.remove();
  }
  /**
   * Remove any toolbars in all open files.
   */
  async removeAllToolbars() {
    let existingToolbars = activeDocument.querySelectorAll(".cg-note-toolbar-container");
    existingToolbars.forEach((toolbar) => {
      toolbar.remove();
    });
  }
  /**
   * Removes toolbar in the current view only if needed: there is no valid toolbar to check against; 
   * the toolbar names don't match; it's out of date with the settings; or it's not in the correct DOM position. 
   * @param correctToolbar ToolbarSettings for the toolbar that should be used.
   * @returns true if the toolbar was removed (or doesn't exist), false otherwise.
   */
  removeToolbarIfNeeded(correctToolbar) {
    let toolbarRemoved = false;
    let existingToolbarEl = this.getToolbarEl();
    debugLog("removeToolbarIfNeeded: correct: ", correctToolbar, "existing: ", existingToolbarEl);
    if (existingToolbarEl) {
      let existingToolbarName = existingToolbarEl == null ? void 0 : existingToolbarEl.getAttribute("data-name");
      let existingToolbarUpdated = existingToolbarEl.getAttribute("data-updated");
      let existingToolbarHasSibling = existingToolbarEl.nextElementSibling;
      if (!correctToolbar) {
        debugLog("- toolbar not needed, removing existing toolbar: " + existingToolbarName);
        toolbarRemoved = true;
      } else if (correctToolbar.name !== existingToolbarName) {
        debugLog("- toolbar needed, removing existing toolbar (name does not match): " + existingToolbarName);
        toolbarRemoved = true;
      } else if (correctToolbar.updated !== existingToolbarUpdated) {
        debugLog("- existing toolbar out of date, removing existing toolbar");
        toolbarRemoved = true;
      } else if (existingToolbarHasSibling == null ? void 0 : existingToolbarHasSibling.hasClass("inline-title")) {
        debugLog("- not in the correct position (sibling is `inline-title`), removing existing toolbar");
        toolbarRemoved = true;
      }
      if (toolbarRemoved) {
        existingToolbarEl.remove();
        existingToolbarEl = null;
      }
    } else {
      debugLog("- no existing toolbar");
      toolbarRemoved = true;
    }
    if (!toolbarRemoved) {
      debugLog("removeToolbarIfNeeded: nothing done");
    }
    return toolbarRemoved;
  }
  /*************************************************************************
   * SETTINGS LOADERS
   *************************************************************************/
  /**
   * Loads settings, and migrates from old versions if needed.
   * 
   * 1. Update SETTINGS_VERSION in NoteToolbarSettings.
   * 2. Add MIGRATION block below.
   * 
   * Credit to Fevol on Discord for the sample code to migrate.
   * @link https://discord.com/channels/686053708261228577/840286264964022302/1213507979782127707
   */
  async loadSettings() {
    var _a, _b, _c, _d, _e;
    const loaded_settings = await this.loadData();
    debugLog("loadSettings: loaded settings: ", loaded_settings);
    this.settings = Object.assign({}, DEFAULT_SETTINGS, loaded_settings);
    let old_version = loaded_settings == null ? void 0 : loaded_settings.version;
    let new_version;
    if (loaded_settings && old_version !== SETTINGS_VERSION) {
      debugLog("loadSettings: versions do not match: data.json: ", old_version, " !== latest: ", SETTINGS_VERSION);
      debugLog("running migrations...");
      if (!old_version) {
        new_version = 202403181e-1;
        debugLog("- starting migration: " + old_version + " -> " + new_version);
        (_a = loaded_settings.toolbars) == null ? void 0 : _a.forEach((tb, index) => {
          if (tb.styles) {
            debugLog("	- OLD SETTING: " + tb.styles);
            debugLog("		- SETTING: this.settings.toolbars[index].defaultStyles: " + this.settings.toolbars[index].defaultStyles);
            this.settings.toolbars[index].defaultStyles = tb.styles;
            debugLog("		- SET: " + this.settings.toolbars[index].defaultStyles);
            debugLog("		- SETTING: this.settings.toolbars[index].mobileStyles = []");
            this.settings.toolbars[index].mobileStyles = [];
            delete tb.styles;
          }
        });
        old_version = new_version;
      }
      if (old_version === 202403181e-1) {
        new_version = 202403221e-1;
        debugLog("- starting migration: " + old_version + " -> " + new_version);
        (_b = loaded_settings.toolbars) == null ? void 0 : _b.forEach((tb, index) => {
          tb.items.forEach((item, item_index) => {
            if (!(item == null ? void 0 : item.urlAttr)) {
              debugLog("  - add urlAttr for: ", tb.name, item.label);
              item.urlAttr = {
                hasVars: true,
                isUri: true
              };
            }
          });
        });
        old_version = new_version;
      }
      if (old_version === 202403221e-1) {
        new_version = 202403301e-1;
        debugLog("- starting migration: " + old_version + " -> " + new_version);
        (_c = loaded_settings.toolbars) == null ? void 0 : _c.forEach((tb, index) => {
          tb.items.forEach((item, item_index) => {
            this.settings.toolbars[index].items[item_index].icon = "";
            if (item.url) {
              this.settings.toolbars[index].items[item_index].link = item.url;
              delete item.url;
            }
            if (item.urlAttr) {
              this.settings.toolbars[index].items[item_index].linkAttr = {
                commandId: "",
                hasVars: item.urlAttr.hasVars,
                type: item.urlAttr.isUri ? "uri" : "file"
              };
              delete item.urlAttr;
            }
          });
        });
        old_version = new_version;
      }
      if (old_version === 202403301e-1) {
        new_version = 202404161e-1;
        debugLog("- starting migration: " + old_version + " -> " + new_version);
        (_d = loaded_settings.toolbars) == null ? void 0 : _d.forEach((tb, index) => {
          tb.items.forEach((item, item_index) => {
            this.settings.toolbars[index].items[item_index].contexts = [{
              platform: migrateItemVisPlatform(item.hideOnDesktop, item.hideOnMobile),
              view: "all"
            }];
            delete item.hideOnDesktop;
            delete item.hideOnMobile;
          });
          this.settings.toolbars[index].positions = [{
            position: "props",
            contexts: [{
              platform: "all",
              view: "all"
            }]
          }];
        });
        old_version = new_version;
      }
      if (old_version === 202404161e-1) {
        new_version = 202404261e-1;
        debugLog("- starting migration: " + old_version + " -> " + new_version);
        (_e = loaded_settings.toolbars) == null ? void 0 : _e.forEach((tb, index) => {
          var _a2;
          if (this.settings.toolbars[index].positions) {
            (_a2 = this.settings.toolbars[index].positions) == null ? void 0 : _a2.forEach((pos, posIndex) => {
              var _a3;
              this.settings.toolbars[index].position = {};
              if (pos.contexts) {
                (_a3 = pos.contexts) == null ? void 0 : _a3.forEach((ctx, ctxIndex) => {
                  if (pos.position) {
                    switch (ctx.platform) {
                      case "desktop":
                        this.settings.toolbars[index].position.desktop = {
                          allViews: { position: pos.position }
                        };
                        break;
                      case "mobile":
                        this.settings.toolbars[index].position.mobile = {
                          allViews: { position: pos.position }
                        };
                        this.settings.toolbars[index].position.tablet = {
                          allViews: { position: pos.position }
                        };
                        break;
                      case "all":
                        this.settings.toolbars[index].position.desktop = {
                          allViews: { position: pos.position }
                        };
                        this.settings.toolbars[index].position.mobile = {
                          allViews: { position: pos.position }
                        };
                        this.settings.toolbars[index].position.tablet = {
                          allViews: { position: pos.position }
                        };
                        break;
                    }
                  }
                });
              }
            });
            delete this.settings.toolbars[index].positions;
          }
          tb.items.forEach((item, item_index) => {
            var _a3;
            if (this.settings.toolbars[index].items[item_index].contexts) {
              (_a3 = this.settings.toolbars[index].items[item_index].contexts) == null ? void 0 : _a3.forEach((ctx, ctxIndex) => {
                if (!this.settings.toolbars[index].items[item_index].visibility) {
                  this.settings.toolbars[index].items[item_index].visibility = {};
                  switch (ctx.platform) {
                    case "desktop":
                      this.settings.toolbars[index].items[item_index].visibility.desktop = {
                        allViews: { components: ["icon", "label"] }
                      };
                      break;
                    case "mobile":
                      this.settings.toolbars[index].items[item_index].visibility.mobile = {
                        allViews: { components: ["icon", "label"] }
                      };
                      this.settings.toolbars[index].items[item_index].visibility.tablet = {
                        allViews: { components: ["icon", "label"] }
                      };
                      break;
                    case "all":
                      this.settings.toolbars[index].items[item_index].visibility.desktop = {
                        allViews: { components: ["icon", "label"] }
                      };
                      this.settings.toolbars[index].items[item_index].visibility.mobile = {
                        allViews: { components: ["icon", "label"] }
                      };
                      this.settings.toolbars[index].items[item_index].visibility.tablet = {
                        allViews: { components: ["icon", "label"] }
                      };
                      break;
                    case "none":
                    default:
                      break;
                  }
                }
              });
              delete this.settings.toolbars[index].items[item_index].contexts;
            }
          });
        });
        old_version = new_version;
      }
      this.settings.version = SETTINGS_VERSION;
      debugLog("updated settings:", this.settings);
      await this.saveSettings();
    }
  }
  /**
   * Saves settings.
   * Sorts the toolbar list (by name) first.
   */
  async saveSettings() {
    await this.saveData(this.settings);
    await this.removeActiveToolbar();
    await this.renderToolbarForActiveFile();
    debugLog("SETTINGS SAVED: " + new Date().getTime());
  }
  /**
   * Loads settings if the data file is changed externally (e.g., by Obsidian Sync).
   */
  async onExternalSettingsChange() {
    debugLog("onExternalSettingsChange()");
  }
  /**
   * Gets toolbar from settings, using the provided name.
   * @param name Name of toolbar to get settings for (case-insensitive).
   * @returns ToolbarSettings for the provided matched toolbar name, undefined otherwise.
   */
  getToolbarSettings(name) {
    return name ? this.settings.toolbars.find((tbar) => tbar.name.toLowerCase() === name.toLowerCase()) : void 0;
  }
  /**
   * Gets toolbar from settings, using the provided array of strings (which will come from note frontmatter).
   * @param names List of potential toolbars to get settings for (case-insensitive); only the first match is returned.
   * @returns ToolbarSettings for the provided matched toolbar name, undefined otherwise.
   */
  getToolbarSettingsFromProps(names) {
    if (!names)
      return void 0;
    if (typeof names === "string") {
      return this.getToolbarSettings(names);
    }
    return this.settings.toolbars.find((tbar) => names.some((name) => tbar.name.toLowerCase() === name.toLowerCase()));
  }
  /**
   * Removes the provided toolbar from settings; does nothing if it does not exist.
   * @param name Name of the toolbar to remove.
   */
  deleteToolbarFromSettings(name) {
    this.settings.toolbars = this.settings.toolbars.filter((tbar) => tbar.name !== name);
  }
};
